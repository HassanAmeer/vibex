<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VibeAll Web Preview</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #1e1e1e;
            color: #cccccc;
        }

        :root {
            --vscode-editor-background: #1e1e1e;
            --vscode-editor-foreground: #cccccc;
            --vscode-sideBar-background: #252526;
            --vscode-panel-border: rgba(128, 128, 128, 0.35);
            --vscode-button-background: #0e639c;
            --vscode-button-foreground: #ffffff;
            --vscode-button-hoverBackground: #1177bb;
            --vscode-button-secondaryBackground: #3a3d41;
            --vscode-button-secondaryForeground: #ffffff;
            --vscode-button-secondaryHoverBackground: #45494e;
            --vscode-input-background: #3c3c3c;
            --vscode-input-border: #3c3c3c;
            --vscode-input-foreground: #cccccc;
            --vscode-input-placeholderForeground: #a6a6a6;
            --vscode-list-hoverBackground: #2a2d2e;
            --vscode-descriptionForeground: #8b949e;
            --vscode-textCodeBlock-background: #0a0a0a;
            --vscode-widget-border: #454545;
            --vscode-scrollbarSlider-background: rgba(121, 121, 121, 0.4);
            --vscode-scrollbarSlider-hoverBackground: rgba(100, 100, 100, 0.7);
            --vscode-dropdown-background: #3c3c3c;
            --vscode-dropdown-foreground: #f0f0f0;
            --vscode-textBlockQuote-background: rgba(127, 127, 127, 0.1);
            --glass-bg: rgba(30, 30, 30, 0.8);
            --glass-border: rgba(255, 255, 255, 0.1);
        }

        /* Lightweight Toast Notification */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            pointer-events: none;
        }

        .toast {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.95), rgba(5, 150, 105, 0.95));
            color: white;
            padding: 12px 20px;
            border-radius: 12px;
            margin-bottom: 10px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
            font-weight: 500;
            min-width: 280px;
            pointer-events: auto;
            animation: slideInRight 0.3s ease-out, fadeOut 0.3s ease-in 2.7s forwards;
        }

        .toast.error {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.95), rgba(220, 38, 38, 0.95));
        }

        .toast.info {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.95), rgba(37, 99, 235, 0.95));
        }

        .toast-icon {
            font-size: 18px;
            flex-shrink: 0;
        }

        .toast-message {
            flex: 1;
        }

        @keyframes slideInRight {
            from {
                transform: translateX(400px);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes fadeOut {
            to {
                opacity: 0;
                transform: translateX(20px);
            }
        }
    </style>
    <script>
        // Toast Notification System
        function showToast(message, type = 'success') {
            console.log('[Toast]', type, message);

            // Create container if it doesn't exist
            let container = document.querySelector('.toast-container');
            if (!container) {
                container = document.createElement('div');
                container.className = 'toast-container';
                document.body.appendChild(container);
            }

            // Create toast element
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;

            const icon = type === 'success' ? 'âœ“' : type === 'error' ? 'âœ—' : 'â„¹';

            toast.innerHTML = `
                <span class="toast-icon">${icon}</span>
                <span class="toast-message">${message}</span>
            `;

            container.appendChild(toast);

            // Auto remove after animation
            setTimeout(() => {
                toast.remove();
                // Remove container if empty
                if (container.children.length === 0) {
                    container.remove();
                }
            }, 3000);
        }

        // Mock State Persistence
        const mockApiKeys = JSON.parse(localStorage.getItem('vibeall_mock_keys') || '{"openrouter": "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"}');
        const mockSettings = JSON.parse(localStorage.getItem('vibeall_mock_settings') || '{"autoRunCommands": false, "autoApplyEdits": false, "showMiniDashboard": true, "compactMode": false, "theme": { "primaryColor": "#6366f1", "accentColor": "#8b5cf6", "mode": "dark" }}');

        window.acquireVsCodeApi = () => {
            return {
                postMessage: (message) => {
                    console.log('ðŸ“¤ [Mock] Post Message:', message);
                    setTimeout(() => handleMockResponse(message), 100);
                },
                setState: (state) => {
                    console.log('ðŸ’¾ [Mock] Set State:', state);
                    localStorage.setItem('vscodeState', JSON.stringify(state));
                },
                getState: () => {
                    return JSON.parse(localStorage.getItem('vscodeState') || '{}');
                }
            };
        };

        // LiveDB Configuration
        const LIVEDB_BASE_URL = 'https://link.thelocalrent.com/api/db';
        const LIVEDB_TOKEN = '37160f2e00721d906831565829ae1de7';
        const PROJECT_NAME = 'vibex';
        const COLLECTION_NAME = 'api_keys';

        // Generate or retrieve user ID
        let userId = localStorage.getItem('vibeall_user_id');
        if (!userId) {
            userId = `web_user_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;
            localStorage.setItem('vibeall_user_id', userId);
            console.log('[LiveDB] Generated new user ID:', userId);
        }

        // Sync API key to LiveDB
        async function syncToLiveDB(provider, key) {
            console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
            console.log('[LiveDB] ðŸš€ STARTING API KEY SYNC');
            console.log('[LiveDB] Provider:', provider);
            console.log('[LiveDB] Key length:', key.length);
            console.log('[LiveDB] User ID:', userId);
            console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');

            try {
                const url = `${LIVEDB_BASE_URL}/${PROJECT_NAME}/${COLLECTION_NAME}`;
                console.log('[LiveDB] Step 1: Base URL constructed:', url);

                // Check if key already exists
                console.log('[LiveDB] Step 2: Checking if key already exists...');
                const existing = await getFromLiveDB(provider);

                if (existing && existing.id) {
                    console.log('[LiveDB] Step 3: âœ“ Found existing key with ID:', existing.id);
                    console.log('[LiveDB] Step 4: Preparing UPDATE request...');

                    const updateUrl = `${url}/${existing.id}`;
                    const payload = {
                        provider,
                        key,
                        user_id: userId,
                        updated_at: new Date().toISOString()
                    };

                    console.log('[LiveDB] Update URL:', updateUrl);
                    console.log('[LiveDB] Update Payload:', { ...payload, key: '***' });

                    console.log('[LiveDB] Step 5: Sending PUT request...');
                    const response = await fetch(updateUrl, {
                        method: 'PUT',
                        headers: {
                            'Authorization': `Bearer ${LIVEDB_TOKEN}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(payload)
                    });

                    console.log('[LiveDB] Step 6: Response received');
                    console.log('[LiveDB] Response Status:', response.status, response.statusText);

                    if (response.ok) {
                        const result = await response.json();
                        console.log('[LiveDB] Response Data:', result);
                        console.log('[LiveDB] âœ… âœ… âœ… SUCCESSFULLY UPDATED API KEY FOR:', provider);
                    } else {
                        const errorText = await response.text();
                        console.error('[LiveDB] âŒ UPDATE FAILED!');
                        console.error('[LiveDB] Error Response:', errorText);
                    }
                } else {
                    console.log('[LiveDB] Step 3: âœ— No existing key found');
                    console.log('[LiveDB] Step 4: Preparing CREATE request...');

                    const payload = {
                        provider,
                        key,
                        user_id: userId,
                        created_at: new Date().toISOString()
                    };

                    console.log('[LiveDB] Create URL:', url);
                    console.log('[LiveDB] Create Payload:', { ...payload, key: '***' });

                    console.log('[LiveDB] Step 5: Sending POST request...');
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${LIVEDB_TOKEN}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(payload)
                    });

                    console.log('[LiveDB] Step 6: Response received');
                    console.log('[LiveDB] Response Status:', response.status, response.statusText);

                    if (response.ok) {
                        const result = await response.json();
                        console.log('[LiveDB] Response Data:', result);
                        console.log('[LiveDB] âœ… âœ… âœ… SUCCESSFULLY CREATED API KEY FOR:', provider);
                    } else {
                        const errorText = await response.text();
                        console.error('[LiveDB] âŒ CREATE FAILED!');
                        console.error('[LiveDB] Error Response:', errorText);
                    }
                }

                console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                console.log('[LiveDB] ðŸŽ‰ SYNC PROCESS COMPLETED');
                console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');

            } catch (error) {
                console.error('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                console.error('[LiveDB] âŒ âŒ âŒ SYNC ERROR!');
                console.error('[LiveDB] Error Type:', error.name);
                console.error('[LiveDB] Error Message:', error.message);
                console.error('[LiveDB] Error Stack:', error.stack);
                console.error('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                throw error;
            }
        }

        // Get API key from LiveDB
        async function getFromLiveDB(provider) {
            console.log('[LiveDB] ðŸ” Checking for existing key:', provider);
            try {
                const url = `${LIVEDB_BASE_URL}/${PROJECT_NAME}/${COLLECTION_NAME}?provider=${provider}&user_id=${userId}`;
                console.log('[LiveDB] Query URL:', url);

                const response = await fetch(url, {
                    headers: {
                        'Authorization': `Bearer ${LIVEDB_TOKEN}`
                    }
                });

                console.log('[LiveDB] Query Response Status:', response.status);

                if (response.ok) {
                    const result = await response.json();
                    console.log('[LiveDB] Query Result:', result);

                    if (result.success && result.data && result.data.length > 0) {
                        console.log('[LiveDB] âœ“ Found existing key, ID:', result.data[0].id);
                        return result.data[0];
                    } else {
                        console.log('[LiveDB] âœ— No existing key found');
                    }
                } else {
                    console.error('[LiveDB] Query failed with status:', response.status);
                }
                return null;
            } catch (error) {
                console.error('[LiveDB] Get error:', error.message);
                return null;
            }
        }

        // Delete API key from LiveDB
        async function deleteFromLiveDB(provider) {
            try {
                const existing = await getFromLiveDB(provider);
                if (!existing || !existing.id) {
                    return;
                }

                const url = `${LIVEDB_BASE_URL}/${PROJECT_NAME}/${COLLECTION_NAME}/${existing.id}`;
                const response = await fetch(url, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${LIVEDB_TOKEN}`
                    }
                });

                if (response.ok) {
                    console.log('[LiveDB] âœ… Deleted API key for:', provider);
                } else {
                    console.error('[LiveDB] Delete failed:', await response.text());
                }
            } catch (error) {
                console.error('[LiveDB] Delete error:', error);
                throw error;
            }
        }

        // Load all API keys from LiveDB on startup
        async function loadFromLiveDB() {
            console.log('ðŸŒ LOADING API KEYS FROM LIVEDB ON STARTUP');
            console.log('User ID:', userId);

            try {
                const url = `${LIVEDB_BASE_URL}/${PROJECT_NAME}/${COLLECTION_NAME}?user_id=${userId}`;
                console.log('[Load] Request URL:', url);

                const response = await fetch(url, {
                    headers: {
                        'Authorization': `Bearer ${LIVEDB_TOKEN}`
                    }
                });

                console.log('[Load] Response Status:', response.status);

                if (response.ok) {
                    const result = await response.json();
                    console.log('[Load] Response Data:', result);

                    if (result.success && result.data) {
                        console.log('[Load] âœ… Found', result.data.length, 'API keys in cloud');

                        if (result.data.length > 0) {
                            console.log('[Load] Merging with local storage...');
                            result.data.forEach(item => {
                                console.log(`[Load] - ${item.provider}: ${item.key ? 'exists' : 'missing'}`);
                                if (!mockApiKeys[item.provider]) {
                                    mockApiKeys[item.provider] = item.key;
                                    console.log(`[Load]   âœ“ Added ${item.provider} to local storage`);
                                } else {
                                    console.log(`[Load]   âŠ˜ ${item.provider} already in local storage, skipping`);
                                }
                            });
                            localStorage.setItem('vibeall_mock_keys', JSON.stringify(mockApiKeys));
                            console.log('[Load] âœ“ Updated localStorage');
                        } else {
                            console.log('[Load] No keys found in cloud');
                        }
                    } else {
                        console.log('[Load] Invalid response format');
                    }
                } else {
                    console.error('[Load] âŒ Request failed with status:', response.status);
                }
            } catch (error) {
                console.error('[Load] âŒ Load error:', error.message);
                console.error('[Load] Error details:', error);
            }

            console.log('ðŸŒ LOAD FROM LIVEDB COMPLETED');
        }

        // Load from LiveDB on page load
        loadFromLiveDB();

        async function handleMockResponse(message) {
            switch (message.type) {
                case 'getSettings':
                    dispatch({ type: 'settings', payload: mockSettings });
                    break;

                case 'updateSettings':
                    Object.assign(mockSettings, message.payload);
                    localStorage.setItem('vibeall_mock_settings', JSON.stringify(mockSettings));
                    break;

                case 'getChatHistory':
                    dispatch({ type: 'chatHistory', payload: [] });
                    break;

                case 'getUsageStats':
                    dispatch({
                        type: 'usageStats',
                        payload: { groq: { requests: 10, tokens: 500, lastUsed: Date.now() } }
                    });
                    break;

                case 'getAPIKeys':
                    // Send as key-value map (new format)
                    dispatch({ type: 'apiKeysLoaded', payload: mockApiKeys });
                    break;

                case 'storeAPIKey':
                    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                    console.log('ðŸ“¥ RECEIVED storeAPIKey MESSAGE');
                    console.log('Provider:', message.payload.provider);
                    console.log('Key length:', message.payload.key?.length || 0);
                    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

                    const { provider, key } = message.payload;
                    if (key) {
                        console.log('[Handler] Step 1: Saving to mockApiKeys object...');
                        mockApiKeys[provider] = key;
                        console.log('[Handler] Step 2: Saving to localStorage...');
                        localStorage.setItem('vibeall_mock_keys', JSON.stringify(mockApiKeys));
                        console.log('[Handler] âœ“ Saved to localStorage');

                        console.log('[Handler] Step 3: Starting LiveDB sync...');
                        // Sync to LiveDB
                        syncToLiveDB(provider, key).then(() => {
                            console.log('[Handler] âœ“ LiveDB sync completed successfully');
                            showToast(`âœ“ ${provider.charAt(0).toUpperCase() + provider.slice(1)} API key saved successfully!`, 'success');
                        }).catch(err => {
                            console.error('[Handler] âœ— LiveDB sync failed:', err);
                            showToast(`Failed to sync ${provider} key to cloud: ${err.message}`, 'error');
                        });
                    } else {
                        console.log('[Handler] Empty key, deleting from storage...');
                        delete mockApiKeys[provider];
                        localStorage.setItem('vibeall_mock_keys', JSON.stringify(mockApiKeys));
                        showToast(`${provider.charAt(0).toUpperCase() + provider.slice(1)} API key removed`, 'info');
                    }

                    console.log('[Handler] Step 4: Dispatching apiKeyStored confirmation...');
                    dispatch({ type: 'apiKeyStored', payload: { provider } });
                    console.log('[Handler] âœ… Handler completed');
                    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                    break;

                case 'deleteAPIKey':
                    const { provider: delProvider } = message.payload;
                    delete mockApiKeys[delProvider];
                    localStorage.setItem('vibeall_mock_keys', JSON.stringify(mockApiKeys));
                    // Delete from LiveDB
                    deleteFromLiveDB(delProvider).then(() => {
                        showToast(`${delProvider.charAt(0).toUpperCase() + delProvider.slice(1)} API key deleted`, 'success');
                    }).catch(err => {
                        console.error('[LiveDB] Delete failed:', err);
                        showToast(`Failed to delete ${delProvider} key from cloud`, 'error');
                    });
                    dispatch({ type: 'apiKeyDeleted', payload: { provider: delProvider, success: true } });
                    break;

                case 'sendMessage':
                    dispatch({ type: 'messageLoading' });
                    await handleSendMessage(message.payload);
                    break;

                case 'getLogs':
                    dispatch({
                        type: 'logs',
                        payload: [
                            { id: '1', level: 'info', message: 'Webview mock initialized', timestamp: Date.now() }
                        ]
                    });
                    break;
            }
        }

        function dispatch(msg) {
            window.postMessage(msg, '*');
        }

        async function handleSendMessage(payload) {
            const { provider, modelId, messages } = payload;
            const apiKey = mockApiKeys[provider];

            // Sanitize messages to remove 'id' and other internal properties that APIs might reject
            const cleanMessages = messages.map(m => ({
                role: m.role,
                content: m.content
            }));

            if (!apiKey) {
                dispatch({
                    type: 'messageError',
                    payload: { error: `No API key for ${provider}. Configure in Settings.` }
                });
                return;
            }

            try {
                let responseContent = '';
                let totalTokens = 0;

                // Proxy map based on webpack configuration
                const API_MAP = {
                    groq: {
                        url: '/proxy/groq/openai/v1/chat/completions',
                        headers: { 'Authorization': `Bearer ${apiKey}` },
                        body: (msgs) => ({ model: modelId, messages: msgs, temperature: 0.7 })
                    },
                    openai: {
                        url: '/proxy/openai/v1/chat/completions',
                        headers: { 'Authorization': `Bearer ${apiKey}` },
                        body: (msgs) => ({ model: modelId, messages: msgs })
                    },
                    cerebras: {
                        url: '/proxy/cerebras/v1/chat/completions',
                        headers: { 'Authorization': `Bearer ${apiKey}` },
                        body: (msgs) => ({ model: modelId, messages: msgs })
                    },
                    sambanova: {
                        url: '/proxy/sambanova/v1/chat/completions',
                        headers: { 'Authorization': `Bearer ${apiKey}` },
                        body: (msgs) => ({ model: modelId, messages: msgs })
                    },
                    google: {
                        url: `/proxy/google/v1beta/models/${modelId}:generateContent?key=${apiKey}`,
                        headers: {},
                        body: (msgs) => {
                            const contents = msgs.map(m => ({
                                role: m.role === 'assistant' ? 'model' : 'user',
                                parts: [{ text: m.content }]
                            }));
                            return { contents };
                        }
                    },
                    anthropic: {
                        url: '/proxy/anthropic/v1/messages',
                        headers: { 'x-api-key': apiKey, 'anthropic-version': '2023-06-01', 'anthropic-dangerous-direct-browser-access': 'true' },
                        body: (msgs) => {
                            // Correct formatting for Anthropic
                            const systemMsg = msgs.find(m => m.role === 'system');
                            const otherMsgs = msgs.filter(m => m.role !== 'system');
                            return {
                                model: modelId,
                                messages: otherMsgs,
                                max_tokens: 4096,
                                system: systemMsg ? systemMsg.content : undefined
                            };
                        }
                    },
                    xai: {
                        url: '/proxy/xai/v1/chat/completions',
                        headers: { 'Authorization': `Bearer ${apiKey}` },
                        body: (msgs) => ({ model: modelId, messages: msgs, stream: false, temperature: 0 })
                    },
                    novita: {
                        url: '/proxy/novita/openai/chat/completions',
                        headers: { 'Authorization': `Bearer ${apiKey}` },
                        body: (msgs) => ({ model: modelId, messages: msgs, temperature: 0.7, max_tokens: 1000 })
                    },
                    bytez: {
                        url: `/proxy/bytez/models/v2/${modelId}`,
                        headers: { 'Authorization': `Key ${apiKey}` },
                        body: (msgs) => {
                            let input = msgs;
                            const isEmbedding = modelId.includes('sentence-transformers') ||
                                modelId.includes('bge') ||
                                modelId.includes('nomic') ||
                                modelId.includes('clip') ||
                                modelId.includes('siglip');

                            const isMedia = modelId.includes('stable') ||
                                modelId.includes('whisper') ||
                                modelId.includes('bark');

                            // For non-chat models (embeddings, media), use the last message content only
                            if (isEmbedding || isMedia) {
                                input = msgs[msgs.length - 1].content;
                            }

                            const body = { input };
                            // Only add params for models that support it (LLMs)
                            if (!isEmbedding && !modelId.includes('whisper') && !modelId.includes('bark')) {
                                body.params = { max_tokens: 1024 };
                            }
                            return body;
                        }
                    },
                    aimlapi: {
                        url: '/proxy/aimlapi/v1/chat/completions',
                        headers: { 'Authorization': `Bearer ${apiKey}` },
                        body: (msgs) => ({ model: modelId, messages: msgs, temperature: 0.7, max_tokens: 4096 })
                    },
                    openrouter: {
                        url: '/proxy/openrouter/api/v1/chat/completions',
                        headers: { 'Authorization': `Bearer ${apiKey}` },
                        body: (msgs) => {
                            const body = { model: modelId, messages: msgs, temperature: 0.7 };
                            if (modelId.includes('think') || modelId.includes('reason')) {
                                body.reasoning = { enabled: true };
                            }
                            return body;
                        }
                    }
                };

                const config = API_MAP[provider.toLowerCase()] || API_MAP['openai']; // Default to generic

                console.log(`ðŸ“¡ Sending request to generic proxy for ${provider}...`);

                const res = await fetch(config.url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', ...config.headers },
                    body: JSON.stringify(config.body(cleanMessages))
                });

                if (!res.ok) {
                    const txt = await res.text();
                    throw new Error(`API Error ${res.status}: ${txt}`);
                }

                const data = await res.json();

                // Parse response based on provider
                if (provider === 'google') {
                    responseContent = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
                    totalTokens = data.usageMetadata?.totalTokenCount || 0;
                } else if (provider === 'anthropic') {
                    responseContent = data.content?.[0]?.text || '';
                    totalTokens = data.usage?.output_tokens || 0;
                } else if (provider === 'bytez') {
                    // Handle variable Bytez output (string, array, object)
                    responseContent = typeof data.output === 'string'
                        ? data.output
                        : (data.output?.[0]?.content || JSON.stringify(data.output));
                    totalTokens = 0; // Not returned standardly
                } else if (provider === 'openrouter') {
                    responseContent = data.choices?.[0]?.message?.content || '';
                    totalTokens = data.usage?.total_tokens || 0;
                    // The reasoning details from OpenRouter could be captured here if the UI supported displaying them separately
                    // For now, we just pass the content.
                } else {
                    responseContent = data.choices?.[0]?.message?.content || '';
                    totalTokens = data.usage?.total_tokens || 0;
                }

                if (!responseContent) throw new Error('Empty response from AI provider');

                dispatch({
                    type: 'messageResponse',
                    payload: {
                        content: responseContent,
                        model: modelId,
                        tokens: totalTokens,
                        usedProvider: provider
                    }
                });

            } catch (error) {
                console.error(error);
                dispatch({
                    type: 'messageError',
                    payload: { error: `Proxy Request Failed: ${error.message}. Ensure "npm run web" is running.` }
                });
            }
        }
    </script>
</head>

<body>
    <div id="root"></div>
</body>

</html>
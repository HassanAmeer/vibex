{"version":3,"file":"extension.js","mappings":"0GAEA,sBAII,WAAAA,CAAYC,EAAgBC,GACxBC,KAAKF,OAASA,EACdE,KAAKD,QAAUA,CACnB,CAQU,iBAAME,CACZC,EACAC,EACAC,GAEA,MAAMC,QAAiBC,MAAM,GAAGN,KAAKD,UAAUG,IAAY,CACvDK,OAAQ,OACRC,QAAS,CACL,eAAgB,mBAChB,cAAiB,UAAUR,KAAKF,YAC7BM,GAASI,SAEhBL,KAAMM,KAAKC,UAAUP,MAClBC,IAGP,IAAKC,EAASM,GACV,MAAM,IAAIC,MAAM,uBAAuBP,EAASQ,cAGpD,OAAOR,CACX,E,mFCtCJ,cAGA,MAAaS,UAAoB,EAAAC,cAC7B,WAAAlB,CAAYC,GACRkB,MAAMlB,EAAQ,kCAClB,CAEA,iBAAMmB,CACFC,EACAC,GAMA,IAAIC,EAAaD,EAEjB,MAAME,EAAcH,EAAQI,SAAS,0BACjCJ,EAAQI,SAAS,QACjBJ,EAAQI,SAAS,UACjBJ,EAAQI,SAAS,SACjBJ,EAAQI,SAAS,UAEfC,EAAUL,EAAQI,SAAS,WAC7BJ,EAAQI,SAAS,YACjBJ,EAAQI,SAAS,QAGrB,GAAID,GAAeE,EAAS,CACxB,MAAMC,EAAUL,EAASA,EAASM,OAAS,GAC3CL,EAAQI,EAAUA,EAAQE,QAAU,EACxC,CAEA,MAAMC,EAAmB,CAAEP,SAItBC,GAAgBH,EAAQI,SAAS,YAAeJ,EAAQI,SAAS,UAClEK,EAAYC,OAAS,CACjBC,WAAY,KACZC,YAAa,KAIrB,MAAMzB,QAAiBL,KAAKC,YAAY,IAAIiB,IAAWS,GAGjDI,SADa1B,EAAS2B,QACRD,OAGpB,IAAIL,EAAU,GAUd,OARIA,EADkB,iBAAXK,EACGA,EACHE,MAAMC,QAAQH,IAAWA,EAAO,IAAMA,EAAO,GAAGL,QAE7CK,EAAO,GAAGL,QAEVjB,KAAKC,UAAUqB,GAGtB,CACHL,QAASA,EACTS,MAAM,EACNC,MAAOlB,EACPmB,OAAQ,EAEhB,CAIU,iBAAMpC,CAAYC,EAAkBC,GAC1C,MAAMmC,EAAM,GAAGtC,KAAKD,UAAUG,IACxBM,EAAU,CACZ,eAAgB,mBAChB,cAAiB,OAAOR,KAAKF,UAG3BO,QAAiBC,MAAMgC,EAAK,CAC9B/B,OAAQ,OACRC,UACAL,KAAMM,KAAKC,UAAUP,KAGzB,IAAKE,EAASM,GAAI,CACd,MAAM4B,QAAkBlC,EAASmC,OACjC,MAAM,IAAI5B,MAAM,uBAAuBP,EAASoC,UAAUpC,EAASQ,gBAAgB0B,IACvF,CAEA,OAAOlC,CACX,EAvFJ,e,01BCYA,oBAAyBqC,GACrBC,QAAQC,IAAI,oCAEZ,MAAMC,EAAiB,IAAI,EAAAC,eAAeJ,GAEpCK,GADiB,IAAI,EAAAC,eACD,IAAI,EAAAC,mBACxBC,EAAc,IAAI,EAAAC,YAGlBC,EAAgBC,EAAOC,OAAOC,oBAAoB,WAGxD,IAiDIC,EAjDAC,EAAmB,GAEvB,SAASb,EAAIc,EAA+CC,EAAiBC,GACzE,MAAMC,EAAkB,CACpBC,GAAIC,KAAKC,MAAMC,WAAaC,KAAKC,SAASF,SAAS,IAAIG,OAAO,EAAG,GACjEC,UAAWN,KAAKC,MAChBN,QACAC,UACAC,WAGJH,EAAKa,KAAKT,GAGNJ,EAAKhC,OAAS,MACdgC,EAAOA,EAAKc,MAAMd,EAAKhC,OAAS,MAIpC,MAAM4C,EAAY,IAAIN,KAAKF,EAAMQ,WAAWG,qBAC5CpB,EAAcqB,WAAW,IAAIJ,OAAeX,EAAMgB,kBAAkBf,KAChEC,GACAR,EAAcqB,WAAWhE,KAAKC,UAAUkD,EAAS,KAAM,IAI3D3C,EAAY,CACR0D,KAAM,SACNC,QAASf,GAEjB,EAKAgB,iBACI,IACI,MAAMC,QAAgBjC,EAAekC,gBACrCD,EAAQE,QAAQ,EAAGC,WAAUC,UACzBhC,EAAYiC,UAAUF,EAAUC,GAChCtC,EAAI,OAAQ,sBAAsBqC,IAAY,CAAEG,UAAWF,EAAIzD,WAEnEmB,EAAI,OAAQ,UAAUkC,EAAQrD,kBAClC,CAAE,MAAO4D,GACLzC,EAAI,QAAS,0BAA2ByC,EAC5C,CACJ,CAbAC,GAkBA,MAAMC,EAAc,KAChB,MAAMC,EAAiBnC,EAAOC,OAAOmC,iBAC/BpC,EAAOC,OAAOmC,iBAAiBC,gBAC/BC,EAEN,GAAInC,EAEA,YADAA,EAAaoC,OAAOJ,GAIxBhC,EAAeH,EAAOC,OAAOuC,mBACzB,UACA,uBACAxC,EAAOyC,WAAWC,IAClB,CACIC,eAAe,EACfC,yBAAyB,EACzBC,mBAAoB,CAChB7C,EAAO8C,IAAIC,KAAKC,EAAKC,KAAK5D,EAAQ6D,cAAe,YAK7D,MAAMC,EAAahD,EAAaiD,QAAQC,aACpCrD,EAAO8C,IAAIC,KAAKC,EAAKC,KAAK5D,EAAQ6D,cAAe,OAAQ,gBAG7D/C,EAAaiD,QAAQE,KA0bzB,SAA2BH,GACvB,MAAO,qdAoBIA,iCAGf,CAldgCI,CAAkBJ,GAG9ChD,EAAaiD,QAAQI,oBACjBhC,MAAOlB,UAgBfkB,eAAoClB,GAChC,MAAM,KAAEgB,EAAI,QAAEC,GAAYjB,EAE1B,IACI,OAAQgB,GACJ,IAAK,cACD1D,EAAY,CACR0D,KAAM,WACNC,QAAS/B,EAAeiE,gBAE5B,MAEJ,IAAK,uBACKjE,EAAekE,eAAenC,GACpChC,EAAI,OAAQ,oBACZ,MAEJ,IAAK,iBACD3B,EAAY,CACR0D,KAAM,cACNC,QAAS/B,EAAemE,mBAE5B,MAEJ,IAAK,kBACKnE,EAAeoE,mBACrBhG,EAAY,CAAE0D,KAAM,gBACpB/B,EAAI,OAAQ,wBACZ,MAEJ,IAAK,UACD3B,EAAY,CACR0D,KAAM,OACNC,QAASnB,IAEb,MAEJ,IAAK,YACDA,EAAO,GACPxC,EAAY,CACR0D,KAAM,OACNC,QAAS,KAEb,MAEJ,IAAK,gBACD3D,EAAY,CACR0D,KAAM,aACNC,QAAS/B,EAAeqE,kBAE5B,MAEJ,IAAK,aAEDjG,EAAY,CACR0D,KAAM,UACNC,cAHkB/B,EAAekC,kBAKrC,MAGJ,IAAK,cACD,IACI,MAAM,SAAEE,EAAQ,IAAEC,GAAQN,QACpB/B,EAAesE,YAAYlC,EAAUC,GAC3ChC,EAAYiC,UAAUF,EAAUC,GAEhCtC,EAAI,OAAQ,sBAAsBqC,KAElChE,EAAY,CACR0D,KAAM,eACNC,QAAS,CAAEK,aAEnB,CAAE,MAAOI,GACLzC,EAAI,QAAS,4BAA4ByC,EAAM1B,WAC/C1C,EAAY,CACR0D,KAAM,cACNC,QAAS,CAAES,MAAOA,EAAM1B,UAEhC,CACA,MAEJ,IAAK,oBA6BjBkB,eAA+BD,GAC3B,MAAM,SAAEzD,EAAQ,SAAE8D,EAAQ,QAAE/D,GAAY0D,EAExC3D,EAAY,CAAE0D,KAAM,mBACpB/B,EAAI,OAAQ,2BAA2BqC,MAAa/D,MAEpD,IAEI,MAAMkG,EAAe,kvBAkBrB,IAAIC,EAAsB,IAAIlG,GAM9B,GALIkG,EAAoB5F,OAAS,GAC7B4F,EAAoBC,QAAQ,CAAEC,KAAM,SAAU7F,QAAS0F,IAIvD1E,EAAS,CACT,MAAM8E,EAAeH,EAAoBI,KAAKC,GAAgB,SAAXA,EAAEH,MACjDC,IACAA,EAAa9F,QAAU,qBAAqBgB,QAAc8E,EAAa9F,UAE/E,CAGA,IAAKwB,EAAYyE,UAAU1C,GAAW,CAClC,MAAMnF,QAAe+C,EAAe+E,UAAU3C,GAC9C,IAAInF,EAGA,MAAM,IAAIc,MAAM,wBAAwBqE,kCAFxC/B,EAAYiC,UAAUF,EAAUnF,EAIxC,CAGA,MAAMO,QAAiB6C,EAAYjC,YAC/B,CAAEgE,WAAU/D,WACZmG,GAIE3F,EAAUrB,EAASqB,QAGzB,IAAImG,EAAiB,KACrB,MAAMC,EAAiB,mDACjBC,EAAQrG,EAAQqG,MAAMD,GAE5B,GAAIC,EACAF,EAAiBE,EAAM,OACpB,CAEH,MAAMC,EAAe,2CACfC,EAAWvG,EAAQqG,MAAMC,GAC3BC,IACAJ,EAAiBI,EAAS,GAElC,CAEA,GAAIJ,EACA,IAGI,MAAMK,EAAWzH,KAAK0H,MAAMN,GACxBK,EAASE,OAASnG,MAAMC,QAAQgG,EAASE,SACzCxF,EAAI,OAAQ,SAASsF,EAASE,MAAM3G,iCAC9B4G,EAAaH,EAASE,OAEpC,CAAE,MAAOE,GACL1F,EAAI,QAAS,4BAA6B0F,GAC1C3F,QAAQ0C,MAAM,+BAAgCwC,EAClD,KACG,CAEHjF,EAAI,OAAQ,uDACZ,MAAM2F,EAoKlB,SAAgC7G,GAC5B,MAAM0G,EAAe,GAEfI,EAAa,4BACnB,IAAIT,EAEJ,KAA8C,QAAtCA,EAAQS,EAAWC,KAAK/G,KAAoB,CAChD,MAAMgH,EAAOX,EAAM,IAAM,MACnBY,EAAOZ,EAAM,GAMnB,IAAIa,EAAW,KACf,MAAMC,EAAeF,EAAKZ,MAAM,uDAMhC,GALIc,IACAD,EAAWC,EAAa,KAIvBD,EAAU,CACX,MAEME,EAFgBpH,EAAQqH,UAAU7E,KAAK8E,IAAI,EAAGjB,EAAMkB,MAAQ,KAAMlB,EAAMkB,OAE9ClB,MAAM,sCAClCe,IACAF,EAAWE,EAAU,GAE7B,CAGA,IAAKF,EAAU,CACX,MAAMM,EAAe,eAATR,EAAwB,KAAgB,eAATA,EAAwB,KAAgB,WAATA,EAAoB,KAAOA,EACrGE,EAAW,kBAAkBR,EAAM3G,OAAS,KAAKyH,GACrD,CAGAN,EAAWA,EAASO,OAEpBf,EAAM9D,KAAK,CACP8E,KAAM,aACNC,KAAM,CACFhD,KAAMuC,EACNlH,QAASiH,IAGrB,CAEA,OAAOP,CACX,CArNmCkB,CAAuB5H,GAE1C6G,EAAe9G,OAAS,GACxBmB,EAAI,OAAQ,SAAS2F,EAAe9G,+CAC9B4G,EAAaE,IAEnB3F,EAAI,OAAQ,0CAEpB,CAGA,MAAM2G,EAAkB,IACjBpI,EACH,CACI2C,GAAIC,KAAKC,MAAMC,WACfsD,KAAM,YACN7F,QAASrB,EAASqB,QAClB2C,UAAWN,KAAKC,MAChB5B,MAAOlB,EACPmB,OAAQhC,EAASmJ,OAAOC,aACxBC,kBAAmBrJ,EAASqJ,0BAG9B7G,EAAe8G,gBAAgBJ,GAGrC,MAAMK,EAAQ/G,EAAeqE,gBACxB0C,EAAM3E,KACP2E,EAAM3E,GAAY,CAAE4E,SAAU,EAAGxH,OAAQ,EAAGyH,SAAU,IAE1DF,EAAM3E,GAAU4E,UAAY,EAC5BD,EAAM3E,GAAU5C,QAAWhC,EAASmJ,OAAOC,cAAgB,EAC3DG,EAAM3E,GAAU6E,SAAW/F,KAAKC,YAC1BnB,EAAekH,iBAAiBH,GAGtC3I,EAAY,CACR0D,KAAM,kBACNC,QAAS,CACLlD,QAASrB,EAASqB,QAClBU,MAAOlB,EACPmB,OAAQhC,EAASmJ,OAAOC,aACxBO,aAAc/E,EACdyE,kBAAmBrJ,EAASqJ,qBAIpC9G,EAAI,OAAQ,6BAA6BqC,IAAY,CAAE5C,OAAQhC,EAASmJ,OAAOC,cAEnF,CAAE,MAAOpE,GACLzC,EAAI,QAAS,yBAAyByC,EAAM1B,UAAW0B,GACvDpE,EAAY,CACR0D,KAAM,eACNC,QAAS,CAAES,MAAOA,EAAM1B,UAEhC,CACJ,CA9KsBsG,CAAgBrF,GACtB,MAEJ,IAAK,cACDhC,EAAI,OAAQ,qBAAqBgC,EAAQK,cAAcL,EAAQ1D,WAC/D,MAEJ,IAAK,kBAyKjB2D,eAA+B8D,GAC3B,IACI,MAAMuB,EAAS7G,EAAOC,OAAOmC,iBAC7B,IAAKyE,EAED,YADA7G,EAAOC,OAAO6G,iBAAiB,0BAI7BD,EAAOE,KAAKC,IACd,MAAMC,EAAWJ,EAAOI,SAClBC,EAAWD,EAASE,OAAOF,EAASG,UAAY,GAChDC,EAAQ,IAAIrH,EAAOsH,MACrB,IAAItH,EAAOuH,SAAS,EAAG,GACvBL,EAASG,MAAMG,KAEnBR,EAAYS,QAAQJ,EAAO/B,KAG/BtF,EAAOC,OAAOyH,uBAAuB,8BACrCnI,EAAI,OAAQ,uBAChB,CAAE,MAAOyC,GACLhC,EAAOC,OAAO6G,iBAAiB,yBAAyB9E,EAAM1B,WAC9Df,EAAI,QAAS,uBAAwByC,EACzC,CACJ,CAhMsB2F,CAAgBpG,EAAQ+D,KAAM/D,EAAQqG,UAC5C,MAEJ,IAAK,yBACKC,EAAuBtG,GAC7B,MAEJ,QACIjC,QAAQC,IAAI,mCAAmC+B,KAE3D,CAAE,MAAOU,GACL1C,QAAQ0C,MAAM,oCAAqCA,GACnDzC,EAAI,QAAS,0BAA0B+B,IAAQU,GAC/CpE,EAAY,CACR0D,KAAM,QACNC,QAAS,CAAES,MAAOA,EAAM1B,UAEhC,CACJ,CA5HkBwH,CAAqBxH,SAE/BgC,EACAjD,EAAQ0I,eAGZ5H,EAAa6H,aACT,KACI7H,OAAemC,GAEnB,KACAjD,EAAQ0I,gBAiShBvG,eAAeqG,EAAuBtG,GAClC,MAAM,OAAE0G,EAAQjF,KAAM4E,EAAQ,QAAEvJ,GAAYkD,EAC5C,IACI,IAAI2G,EACJ,OAAQD,GACJ,IAAK,aACDC,QAAexI,EAAkByI,WAAWP,EAAUvJ,GACtDkB,EAAI,OAAQ,iBAAiB2I,KAC7B,MACJ,IAAK,kBACDA,QAAexI,EAAkB0I,gBAAgBR,GACjDrI,EAAI,OAAQ,sBAAsB2I,KAClC,MACJ,IAAK,WACDA,QAAexI,EAAkB2I,SAAST,GAC1CrI,EAAI,OAAQ,cAAcqI,KAC1B,MACJ,IAAK,YACDM,QAAexI,EAAkB4I,UAAUV,GAC3CrI,EAAI,OAAQ,qBAAqBqI,KACjC,MACJ,IAAK,cACDM,QAAexI,EAAkB6I,YAAYX,EAAUvJ,GACvDkB,EAAI,OAAQ,oBAAoB2I,KAChC,MACJ,QACI,MAAM,IAAI3K,MAAM,yBAAyB0K,KAGjDrK,EAAY,CACR0D,KAAM,qBACNC,QAAS,CAAE0G,SAAQC,SAAQ9I,OAAQ,YAE3C,CAAE,MAAO4C,GACLzC,EAAI,QAAS,8BAA8B0I,IAAUjG,GACrDpE,EAAY,CACR0D,KAAM,qBACNC,QAAS,CAAE0G,SAAQjG,MAAOA,EAAM1B,QAASlB,OAAQ,UAEzD,CACJ,CAIAoC,eAAewD,EAAaD,GACxBnH,EAAY,CACR0D,KAAM,qBACNC,QAAS,CACLwD,MAAOA,EAAMyD,IAAI,CAACC,EAAQC,KAAc,IAAMD,EAAGhI,GAAIiI,QAI7D,IAAK,IAAIA,EAAI,EAAGA,EAAI3D,EAAM3G,OAAQsK,IAAK,CACnC,MAAMC,EAAO5D,EAAM2D,GACnB9K,EAAY,CACR0D,KAAM,aACNC,QAAS,CACLd,GAAIiI,EACJtJ,OAAQ,UACRuJ,KAAMA,EAAK5C,KACX/C,KAAM2F,EAAK3C,KAAKhD,MAAQ2F,EAAK3C,KAAKT,YAI1C,UACUsC,EAAuB,CAAEI,OAAQU,EAAK5C,QAAS4C,EAAK3C,OAC1DpI,EAAY,CACR0D,KAAM,aACNC,QAAS,CAAEd,GAAIiI,EAAGtJ,OAAQ,cAElC,CAAE,MAAOwJ,GACLhL,EAAY,CACR0D,KAAM,aACNC,QAAS,CAAEd,GAAIiI,EAAGtJ,OAAQ,WAE9BG,EAAI,QAAS,eAAeoJ,EAAK5C,OAAQ6C,EAC7C,CACJ,CACJ,CAqDA,SAAShL,EAAY0C,GACbH,GACAA,EAAaiD,QAAQyF,YAAYvI,EAEzC,CA6BA,MAAMwI,EAAc9I,EAAO+I,SAASC,gBAAgB,eAAgB9G,GAC9D+G,EAAkBjJ,EAAO+I,SAASC,gBAAgB,uBAAwB,KAC5E9G,IACAgH,WAAW,KACPtL,EAAY,CAAE0D,KAAM,kBACrB,OAGPjC,EAAQ0I,cAAc9G,KAAK6H,EAAaG,GAGxC/G,GACJ,EAEA,wBACI5C,QAAQC,IAAI,uCAChB,EA9kBA,kBACA,YACA,SACA,SACA,SACA,Q,oFCEA,uBAII,WAAA/C,CAAY6C,GACR1C,KAAK0C,QAAUA,EACf1C,KAAKwM,cAAgB9J,EAAQ+J,OACjC,CAEA,iBAAMtF,CAAYlC,EAAkBC,GAChC,MAAMwH,EAAa,kBAAkBzH,EAAS0H,sBACxC3M,KAAKwM,cAAcI,MAAMF,EAAYxH,GAC3CvC,QAAQC,IAAI,uCAAuCqC,IACvD,CAEA,eAAM2C,CAAU3C,GACZ,MAAMyH,EAAa,kBAAkBzH,EAAS0H,gBAE9C,aADkB3M,KAAKwM,cAAcK,IAAIH,EAE7C,CAEA,mBAAM3H,GACF,MAAM+H,EAAY,CAAC,OAAQ,SAAU,SAAU,WAAY,WAAY,YAAa,aAC9EC,EAAiB,GAEvB,IAAK,MAAM9H,KAAY6H,EAAW,CAC9B,MAAM5H,QAAYlF,KAAK4H,UAAU3C,GAC7BC,GACA6H,EAAKzI,KAAK,CAAEW,WAAUC,OAE9B,CAEA,OAAO6H,CACX,CAEA,kBAAMC,CAAa/H,GACf,MAAMyH,EAAa,kBAAkBzH,EAAS0H,sBACxC3M,KAAKwM,cAAcS,OAAOP,GAChC/J,QAAQC,IAAI,wCAAwCqC,IACxD,CAGA,WAAA6B,GACI,OAAO9G,KAAK0C,QAAQwK,YAAYL,IAAI,mBAAoB,CACpDM,iBAAiB,EACjBC,gBAAgB,EAChBC,mBAAmB,EACnBC,aAAa,EACbC,gBAAgB,EAChBC,UAAU,EACVC,MAAO,CACHC,aAAc,UACdC,YAAa,UACbC,KAAM,SAGlB,CAEA,oBAAM7G,CAAe8G,SACX7N,KAAK0C,QAAQwK,YAAYY,OAAO,mBAAoBD,GAC1DlL,QAAQC,IAAI,oCAChB,CAGA,cAAAoE,GACI,OAAOhH,KAAK0C,QAAQwK,YAAYL,IAAI,sBAAuB,GAC/D,CAEA,qBAAMlD,CAAgBxI,SACZnB,KAAK0C,QAAQwK,YAAYY,OAAO,sBAAuB3M,EACjE,CAEA,sBAAM8F,SACIjH,KAAK0C,QAAQwK,YAAYY,OAAO,sBAAuB,IAC7DnL,QAAQC,IAAI,wCAChB,CAGA,aAAAsE,GACI,OAAOlH,KAAK0C,QAAQwK,YAAYL,IAAI,qBAAsB,CAAC,EAC/D,CAEA,sBAAM9C,CAAiBH,SACb5J,KAAK0C,QAAQwK,YAAYY,OAAO,qBAAsBlE,EAChE,E,SC3FJmE,EAAOC,QAAUC,QAAQ,S,q3BCAzB,kBACA,YACA,YAEA,0BAII,WAAApO,GACIG,KAAKkO,cAAgB7K,EAAO8K,UAAUC,mBAAmB,GAAGC,IAAIC,OAChEtO,KAAKuO,YAAcvO,KAAKkO,cAAgB7H,EAAKC,KAAKtG,KAAKkO,cAAe,OAAS,EACnF,CAEQ,eAAAM,CAAgBC,GACpB,IAAKzO,KAAKkO,cACN,MAAM,IAAItN,MAAM,qBAIpB,OAAIyF,EAAKqI,WAAWD,IACXA,EAAaE,WAAW3O,KAAKkO,eAK3BO,GAEJpI,EAAKC,KAAKtG,KAAKkO,cAAeO,EACzC,CAEQ,aAAAG,CAAc3D,GACbA,EAAS0D,WAAW3O,KAAKuO,YAKlC,CAEA,gBAAM/C,CAAWP,EAAkBvJ,GAC/B,MAAMmN,EAAW7O,KAAKwO,gBAAgBvD,GAGtC,aAFMjL,KAAK8O,sBAAsBzI,EAAK0I,QAAQF,UACxCG,EAAGC,SAASC,UAAUL,EAAUnN,EAAS,QACxCmN,CACX,CAEA,qBAAMpD,CAAgB0D,GAClB,MAAMN,EAAW7O,KAAKwO,gBAAgBW,GAEtC,aADMH,EAAGC,SAASG,MAAMP,EAAU,CAAEQ,WAAW,IACxCR,CACX,CAEA,cAAMnD,CAAST,GACX,MAAM4D,EAAW7O,KAAKwO,gBAAgBvD,GACtC,aAAa+D,EAAGC,SAASvD,SAASmD,EAAU,OAChD,CAEA,eAAMlD,CAAUwD,GACZ,MAAMN,EAAW7O,KAAKwO,gBAAgBW,GAEtC,aADsBH,EAAGC,SAASK,QAAQT,EAAU,CAAEU,eAAe,KACtD1D,IAAIhI,GACRwC,EAAKC,KAAK6I,EAAStL,EAAMuF,MAExC,CAEA,gBAAMoG,CAAWvE,GACb,MAAM4D,EAAW7O,KAAKwO,gBAAgBvD,SAChC+D,EAAGC,SAASQ,OAAOZ,EAC7B,CAEQ,2BAAMC,CAAsBK,GAChC,UACUH,EAAGC,SAASS,OAAOP,EAC7B,CAAE,YACQH,EAAGC,SAASG,MAAMD,EAAS,CAAEE,WAAW,GAClD,CACJ,CAGA,iBAAMzD,CAAYhD,EAAkBlH,GAChC,IAAK1B,KAAKkO,cAAe,MAAM,IAAItN,MAAM,gBACzC,MAAM+O,EAAUtJ,EAAKC,KAAKtG,KAAKkO,cAAe,MAAOtF,GAErD,aADM5I,KAAKwL,WAAWmE,EAASjO,GACxBiO,CACX,E,kFCnFJ,cAGA,MAAaC,UAAmB,EAAA7O,cAC5B,WAAAlB,CAAYC,GACRkB,MAAMlB,EAAQ,iCAClB,CAEA,iBAAMmB,CACFC,EACAC,GAEA,MAAMd,QAAiBL,KAAKC,YAAY,oBAAqB,CACzDmC,MAAOlB,EACPC,WACAW,YAAa,GACbD,WAAY,OAGVgO,QAAaxP,EAAS2B,OAE5B,MAAO,CACHN,QAASmO,EAAKC,QAAQ,GAAGnM,QAAQjC,QACjCS,MAAM,EACNC,MAAOyN,EAAKzN,MACZC,OAAQwN,EAAKrG,OAAOC,aAE5B,EAxBJ,c,mFCHA,eACA,SACA,SACA,SACA,SASA,oBAGI,WAAA5J,GAFQ,KAAAkQ,QAAsC,IAAIC,GAIlD,CAEA,SAAA7K,CAAUF,EAAkBnF,GACxB,MAAMmQ,EAAqBhL,EAAS0H,cACpC,OAAQsD,GACJ,IAAK,OACDjQ,KAAK+P,QAAQG,IAAI,OAAQ,IAAI,EAAAN,WAAW9P,IACxC,MACJ,IAAK,SACDE,KAAK+P,QAAQG,IAAI,SAAU,IAAI,EAAAC,aAAarQ,IAC5C,MACJ,IAAK,YACDE,KAAK+P,QAAQG,IAAI,YAAa,IAAI,EAAAE,gBAAgBtQ,IAClD,MACJ,IAAK,SACL,IAAK,WACL,IAAK,WACL,IAAK,YACL,IAAK,MACL,IAAK,SACL,IAAK,UACL,IAAK,aACDE,KAAK+P,QAAQG,IAAID,EAAoB,IAAI,EAAAI,aAAavQ,EAAQmQ,IAC9D,MACJ,IAAK,QACDjQ,KAAK+P,QAAQG,IAAI,QAAS,IAAI,EAAApP,YAAYhB,IAGtD,CAEA,iBAAMmB,CAAYqP,EAAqBnP,GACnC,MAAM,SAAE8D,EAAQ,QAAE/D,EAAO,OAAEpB,GAAWwQ,EAGlCxQ,GACAE,KAAKmF,UAAUF,EAAUnF,GAG7B,MAAMyQ,EAASvQ,KAAK+P,QAAQlD,IAAI5H,EAAS0H,eACzC,IAAK4D,EACD,MAAM,IAAI3P,MAAM,uCAAuCqE,KAG3D,aAAasL,EAAOtP,YAAYC,EAASC,EAC7C,CAEA,SAAAwG,CAAU1C,GACN,OAAOjF,KAAK+P,QAAQS,IAAIvL,EAAS0H,cACrC,CAEA,qBAAA8D,GACI,OAAOxO,MAAMyO,KAAK1Q,KAAK+P,QAAQhD,OACnC,E,oFCtEJ,cAGA,MAAasD,UAAqB,EAAAtP,cAG9B,WAAAlB,CAAYC,EAAgBmF,EAAmB,UAC3C,MAAM0L,EAAsC,CACxC,OAAU,4BACV,SAAY,6BACZ,SAAY,8BACZ,UAAa,8BACb,IAAO,sBACP,OAAU,+BACV,QAAW,6BACX,WAAc,gCAElB3P,MAAMlB,EAAQ6Q,EAAS1L,IAAa0L,EAAiB,QACrD3Q,KAAKiF,SAAWA,CACpB,CAEA,iBAAMhE,CACFC,EACAC,GAEA,MAAMyD,EAAe,CACjBxC,MAAOlB,EACPC,WACAW,YAAa,GACbD,WAAwB,cAAZX,EAA0B,IAAO,MAI3B,eAAlBlB,KAAKiF,WAA8B/D,EAAQI,SAAS,UAAYJ,EAAQI,SAAS,aACjFsD,EAAQgM,UAAY,CAAEC,SAAS,IAGnC,MAAMxQ,QAAiBL,KAAKC,YAAY,oBAAqB2E,GAEvDiL,QAAaxP,EAAS2B,OAE5B,MAAO,CACHN,QAASmO,EAAKC,QAAQ,GAAGnM,QAAQjC,QACjCS,MAAM,EACNC,MAAOyN,EAAKzN,MACZC,OAAQwN,EAAKrG,OAAOC,aACpBC,kBAAmBmG,EAAKC,QAAQ,GAAGnM,QAAQ+F,kBAEnD,EA7CJ,gB,oFCHA,cAGA,MAAayG,UAAqB,EAAApP,cAC9B,WAAAlB,CAAYC,GACRkB,MAAMlB,EAAQ,mDAClB,CAEA,iBAAMmB,CACFC,EACAC,GAGA,MAAM2P,EAAW3P,EAAS0K,IAAIkF,IAAO,CACjCxJ,KAAmB,cAAbwJ,EAAIxJ,KAAuB,QAAU,OAC3CyJ,MAAO,CAAC,CAAExO,KAAMuO,EAAIrP,aAGlBrB,QAAiBC,MACnB,GAAGN,KAAKD,kBAAkBmB,yBAA+BlB,KAAKF,SAC9D,CACIS,OAAQ,OACRC,QAAS,CAAE,eAAgB,oBAC3BL,KAAMM,KAAKC,UAAU,CAAEoQ,eAI/B,IAAKzQ,EAASM,GACV,MAAM,IAAIC,MAAM,qBAAqBP,EAASQ,cAGlD,MAAMgP,QAAaxP,EAAS2B,OAE5B,MAAO,CACHN,QAASmO,EAAKoB,WAAW,GAAGvP,QAAQsP,MAAM,GAAGxO,KAC7CL,MAAM,EACNC,MAAOlB,EACPmB,OAAQwN,EAAKqB,eAAeC,gBAEpC,EApCJ,gB,k3BCHA,kBAEA,uBACI,0BAAMC,GACF,MAAMlH,EAAS7G,EAAOC,OAAOmC,iBAC7B,IAAKyE,EACD,MAAO,GAGX,MAAMI,EAAWJ,EAAOI,SAClB+G,EAAYnH,EAAOmH,UAEzB,IAAI3O,EAAU,SAAS4H,EAASgH,aAahC,OAZA5O,GAAW,aAAa4H,EAASiH,iBAE5BF,EAAUG,SAKX9O,GAAW,6BAA6B4H,EAASiH,eACjD7O,GAAW4H,EAASmH,UACpB/O,GAAW,YANXA,GAAW,yBAAyB4H,EAASiH,eAC7C7O,GAAW4H,EAASmH,QAAQJ,GAC5B3O,GAAW,WAORA,CACX,CAEA,yBAAMgP,GACF,MAAMtD,EAAmB/K,EAAO8K,UAAUC,iBAC1C,IAAKA,GAAgD,IAA5BA,EAAiB3M,OACtC,MAAO,GAGX,IAAIiB,EAAU,2BACdA,GAAW,SAAS0L,EAAiB,GAAGC,IAAIC,WAG5C,IACI,MAAMqD,EAAiBtO,EAAO8C,IAAIyL,SAASxD,EAAiB,GAAGC,IAAK,gBAC9DwD,QAA2BxO,EAAO8K,UAAUa,GAAGtD,SAASiG,GACxDG,EAAcrR,KAAK0H,MAAM0J,EAAmB5N,YAElDvB,GAAW,4BACPoP,EAAYC,eACZrP,GAAW,iBAAmBsP,OAAOjF,KAAK+E,EAAYC,cAAczL,KAAK,MAAQ,MAEjFwL,EAAYG,kBACZvP,GAAW,oBAAsBsP,OAAOjF,KAAK+E,EAAYG,iBAAiB3L,KAAK,MAAQ,KAE/F,CAAE,MAAOjB,GAET,CAEA,OAAO3C,CACX,CAEA,2BAAMwP,GACF,MAAMhI,EAAS7G,EAAOC,OAAOmC,iBAC7B,IAAKyE,EACD,MAAO,GAGX,MAAMiI,EAAc9O,EAAO+O,UAAUC,eAAenI,EAAOI,SAAS+D,KACpE,GAA2B,IAAvB8D,EAAY1Q,OACZ,MAAO,GAGX,IAAIiB,EAAU,+BAMd,OALAyP,EAAYnN,QAAQ,CAACsN,EAAYrJ,KAC7B,MAAMsJ,EAAWD,EAAWC,WAAalP,EAAOmP,mBAAmB5R,MAAQ,QAAU,UACrF8B,GAAW,GAAGuG,EAAQ,OAAOsJ,WAAkBD,EAAW5H,MAAM+H,MAAMC,KAAO,MAAMJ,EAAW3O,cAG3FjB,CACX,CAEA,oBAAMiQ,GACF,MAAMC,QAAoB5S,KAAKoR,uBAI/B,MAAO,SAHwBpR,KAAK0R,0BAGLkB,YAFE5S,KAAKkS,yBAG1C,E,uFCnFJ,cAGA,MAAa9B,UAAwB,EAAArP,cACjC,WAAAlB,CAAYC,GACRkB,MAAMlB,EAAQ,+BAClB,CAEA,iBAAMmB,CACFC,EACAC,GAGA,IAAIiG,EAAe,GACnB,MAQMjH,EAAO,CACTiC,MAAOlB,EACPC,SAVsBA,EAAS0R,OAAO9B,GACrB,WAAbA,EAAIxJ,OACJH,GAAgB2J,EAAIrP,QAAU,MACvB,IAQXG,WAAY,KACZiR,OAAQ1L,EAAa+B,aAAUxD,GAG7BtF,QAAiBC,MAAM,GAAGN,KAAKD,mBAAoB,CACrDQ,OAAQ,OACRC,QAAS,CACL,eAAgB,mBAChB,YAAaR,KAAKF,OAClB,oBAAqB,cAEzBK,KAAMM,KAAKC,UAAUP,KAGzB,IAAKE,EAASM,GAAI,CACd,MAAM4B,QAAkBlC,EAASmC,OACjC,MAAM,IAAI5B,MAAM,wBAAwBP,EAASoC,YAAYF,IACjE,CAEA,MAAMsN,QAAaxP,EAAS2B,OAE5B,MAAO,CACHN,QAASmO,EAAKnO,QAAQ,GAAGc,KACzBL,MAAM,EACNC,MAAOyN,EAAKzN,MACZC,OAAQwN,EAAKrG,OAAOuJ,cAE5B,EAjDJ,mB,SCHAhF,EAAOC,QAAUC,QAAQ,K,SCAzBF,EAAOC,QAAUC,QAAQ,O,GCCrB+E,EAA2B,CAAC,ECE5BC,EDCJ,SAASC,EAAoBC,GAE5B,IAAIC,EAAeJ,EAAyBG,GAC5C,QAAqBxN,IAAjByN,EACH,OAAOA,EAAapF,QAGrB,IAAID,EAASiF,EAAyBG,GAAY,CAGjDnF,QAAS,CAAC,GAOX,OAHAqF,EAAoBF,GAAUG,KAAKvF,EAAOC,QAASD,EAAQA,EAAOC,QAASkF,GAGpEnF,EAAOC,OACf,CCnB0BkF,CAAoB,K","sources":[".././src/api/BaseAPIClient.ts",".././src/api/BytezClient.ts",".././src/extension.ts",".././src/managers/StorageManager.ts","../external commonjs \"vscode\"",".././src/managers/FileSystemManager.ts",".././src/api/GroqClient.ts",".././src/api/ModelClient.ts",".././src/api/OpenAIClient.ts",".././src/api/GoogleClient.ts",".././src/managers/ContextManager.ts",".././src/api/AnthropicClient.ts","../external node-commonjs \"fs\"","../external node-commonjs \"path\"","../webpack/bootstrap","../webpack/startup"],"sourcesContent":["import { StreamResponse } from '../types';\n\nexport abstract class BaseAPIClient {\n    protected apiKey: string;\n    protected baseURL: string;\n\n    constructor(apiKey: string, baseURL: string) {\n        this.apiKey = apiKey;\n        this.baseURL = baseURL;\n    }\n\n    abstract sendMessage(\n        modelId: string,\n        messages: any[],\n        options?: any\n    ): Promise<StreamResponse>;\n\n    protected async makeRequest(\n        endpoint: string,\n        body: any,\n        options?: RequestInit\n    ): Promise<Response> {\n        const response = await fetch(`${this.baseURL}${endpoint}`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'Authorization': `Bearer ${this.apiKey}`,\n                ...options?.headers\n            },\n            body: JSON.stringify(body),\n            ...options\n        });\n\n        if (!response.ok) {\n            throw new Error(`API request failed: ${response.statusText}`);\n        }\n\n        return response;\n    }\n}\n","import { BaseAPIClient } from './BaseAPIClient';\nimport { StreamResponse } from '../types';\n\nexport class BytezClient extends BaseAPIClient {\n    constructor(apiKey: string) {\n        super(apiKey, 'https://api.bytez.com/models/v2');\n    }\n\n    async sendMessage(\n        modelId: string,\n        messages: any[]\n    ): Promise<StreamResponse> {\n        // Determine input format based on model type or just pass messages for LLMs\n        // For non-chat models (like stable-diffusion), we might want to extract the last prompt.\n        // But for now, let's implement the chat flow primarily.\n\n        let input: any = messages;\n\n        const isEmbedding = modelId.includes('sentence-transformers') ||\n            modelId.includes('bge') ||\n            modelId.includes('nomic') ||\n            modelId.includes('clip') ||\n            modelId.includes('siglip');\n\n        const isMedia = modelId.includes('stable') ||\n            modelId.includes('whisper') ||\n            modelId.includes('bark');\n\n        // Simple heuristic: if modelId implies image generation or embedding, use the last user message text\n        if (isEmbedding || isMedia) {\n            const lastMsg = messages[messages.length - 1];\n            input = lastMsg ? lastMsg.content : '';\n        }\n\n        const requestBody: any = { input };\n\n        // Only add params for models that support it (LLMs)\n        // Whisper/Bark/Embeddings don't use 'max_tokens' in the same way or error out\n        if (!isEmbedding && !modelId.includes('whisper') && !modelId.includes('bark')) {\n            requestBody.params = {\n                max_tokens: 1024,\n                temperature: 0.7\n            };\n        }\n\n        const response = await this.makeRequest(`/${modelId}`, requestBody);\n\n        const data = await response.json();\n        const output = data.output;\n\n        // Handle output format which can vary\n        let content = '';\n        if (typeof output === 'string') {\n            content = output;\n        } else if (Array.isArray(output) && output[0] && output[0].content) {\n            // Chat output: [{ role: 'assistant', content: '...' }]\n            content = output[0].content;\n        } else {\n            content = JSON.stringify(output);\n        }\n\n        return {\n            content: content,\n            done: true,\n            model: modelId,\n            tokens: 0 // Usage not strictly returned in standard wrapper\n        };\n    }\n\n    // Override makeRequest to custom format headers slightly different if needed\n    // Client.ts says: Authorization: Key ${apiKey}\n    protected async makeRequest(endpoint: string, body: any): Promise<Response> {\n        const url = `${this.baseURL}${endpoint}`;\n        const headers = {\n            'Content-Type': 'application/json',\n            'Authorization': `Key ${this.apiKey}`\n        };\n\n        const response = await fetch(url, {\n            method: 'POST',\n            headers,\n            body: JSON.stringify(body)\n        });\n\n        if (!response.ok) {\n            const errorText = await response.text();\n            throw new Error(`API Request Failed: ${response.status} ${response.statusText} - ${errorText}`);\n        }\n\n        return response;\n    }\n}\n","import * as vscode from 'vscode';\nimport * as path from 'path';\nimport { StorageManager } from './managers/StorageManager';\nimport { ContextManager } from './managers/ContextManager';\nimport { FileSystemManager } from './managers/FileSystemManager';\nimport { ModelClient } from './api/ModelClient';\n\ninterface LogEntry {\n    id: string;\n    timestamp: number;\n    level: 'info' | 'warning' | 'error' | 'debug';\n    message: string;\n    details?: any;\n}\n\nexport function activate(context: vscode.ExtensionContext) {\n    console.log('VibeAll extension is now active!');\n\n    const storageManager = new StorageManager(context);\n    const contextManager = new ContextManager();\n    const fileSystemManager = new FileSystemManager();\n    const modelClient = new ModelClient();\n\n    // Output channel for logging\n    const outputChannel = vscode.window.createOutputChannel('VibeAll');\n\n    // In-memory logs\n    let logs: LogEntry[] = [];\n\n    function log(level: 'info' | 'warning' | 'error' | 'debug', message: string, details?: any) {\n        const entry: LogEntry = {\n            id: Date.now().toString() + Math.random().toString(36).substr(2, 9),\n            timestamp: Date.now(),\n            level,\n            message,\n            details\n        };\n\n        logs.push(entry);\n\n        // Keep only last 1000 logs\n        if (logs.length > 1000) {\n            logs = logs.slice(logs.length - 1000);\n        }\n\n        // Send to output channel\n        const timestamp = new Date(entry.timestamp).toLocaleTimeString();\n        outputChannel.appendLine(`[${timestamp}] [${level.toUpperCase()}] ${message}`);\n        if (details) {\n            outputChannel.appendLine(JSON.stringify(details, null, 2));\n        }\n\n        // Broadcast to webview\n        sendMessage({\n            type: 'newLog',\n            payload: entry\n        });\n    }\n\n    // Load API keys on startup\n    loadAPIKeys();\n\n    async function loadAPIKeys() {\n        try {\n            const apiKeys = await storageManager.getAllAPIKeys();\n            apiKeys.forEach(({ provider, key }) => {\n                modelClient.setAPIKey(provider, key);\n                log('info', `Loaded API key for ${provider}`, { keyLength: key.length });\n            });\n            log('info', `Loaded ${apiKeys.length} API keys`);\n        } catch (error: any) {\n            log('error', 'Failed to load API keys', error);\n        }\n    }\n\n    // Create webview panel\n    let currentPanel: vscode.WebviewPanel | undefined = undefined;\n\n    const showWebview = () => {\n        const columnToShowIn = vscode.window.activeTextEditor\n            ? vscode.window.activeTextEditor.viewColumn\n            : undefined;\n\n        if (currentPanel) {\n            currentPanel.reveal(columnToShowIn);\n            return;\n        }\n\n        currentPanel = vscode.window.createWebviewPanel(\n            'vibeall',\n            'VibeAll AI Assistant',\n            vscode.ViewColumn.Two,\n            {\n                enableScripts: true,\n                retainContextWhenHidden: true,\n                localResourceRoots: [\n                    vscode.Uri.file(path.join(context.extensionPath, 'dist'))\n                ]\n            }\n        );\n\n        const webviewUri = currentPanel.webview.asWebviewUri(\n            vscode.Uri.file(path.join(context.extensionPath, 'dist', 'webview.js'))\n        );\n\n        currentPanel.webview.html = getWebviewContent(webviewUri);\n\n        // Handle messages from webview\n        currentPanel.webview.onDidReceiveMessage(\n            async (message) => {\n                await handleWebviewMessage(message);\n            },\n            undefined,\n            context.subscriptions\n        );\n\n        currentPanel.onDidDispose(\n            () => {\n                currentPanel = undefined;\n            },\n            null,\n            context.subscriptions\n        );\n    };\n\n    async function handleWebviewMessage(message: any) {\n        const { type, payload } = message;\n\n        try {\n            switch (type) {\n                case 'getSettings':\n                    sendMessage({\n                        type: 'settings',\n                        payload: storageManager.getSettings()\n                    });\n                    break;\n\n                case 'updateSettings':\n                    await storageManager.updateSettings(payload);\n                    log('info', 'Settings updated');\n                    break;\n\n                case 'getChatHistory':\n                    sendMessage({\n                        type: 'chatHistory',\n                        payload: storageManager.getChatHistory()\n                    });\n                    break;\n\n                case 'clearChat':\n                    await storageManager.clearChatHistory();\n                    sendMessage({ type: 'chatCleared' });\n                    log('info', 'Chat history cleared');\n                    break;\n\n                case 'getLogs':\n                    sendMessage({\n                        type: 'logs',\n                        payload: logs\n                    });\n                    break;\n\n                case 'clearLogs':\n                    logs = [];\n                    sendMessage({\n                        type: 'logs',\n                        payload: []\n                    });\n                    break;\n\n                case 'getUsageStats':\n                    sendMessage({\n                        type: 'usageStats',\n                        payload: storageManager.getUsageStats()\n                    });\n                    break;\n\n                case 'getAPIKeys': {\n                    const apiKeys = await storageManager.getAllAPIKeys();\n                    sendMessage({\n                        type: 'apiKeys',\n                        payload: apiKeys\n                    });\n                    break;\n                }\n\n                case 'storeAPIKey':\n                    try {\n                        const { provider, key } = payload;\n                        await storageManager.storeAPIKey(provider, key);\n                        modelClient.setAPIKey(provider, key);\n\n                        log('info', `API key stored for ${provider}`);\n\n                        sendMessage({\n                            type: 'apiKeyStored',\n                            payload: { provider }\n                        });\n                    } catch (error: any) {\n                        log('error', `Failed to store API key: ${error.message}`);\n                        sendMessage({\n                            type: 'apiKeyError',\n                            payload: { error: error.message }\n                        });\n                    }\n                    break;\n\n                case 'sendMessage':\n                    await handleAIMessage(payload);\n                    break;\n\n                case 'switchModel':\n                    log('info', `Switched model to ${payload.provider} / ${payload.modelId}`);\n                    break;\n\n                case 'applyCode':\n                    await applyCodeToFile(payload.code, payload.filePath);\n                    break;\n\n                case 'fileSystemAction':\n                    await handleFileSystemAction(payload);\n                    break;\n\n                default:\n                    console.log(`[VibeAll] Unknown message type: ${type}`);\n            }\n        } catch (error: any) {\n            console.error(`[VibeAll] Error handling message:`, error);\n            log('error', `Error handling message ${type}`, error);\n            sendMessage({\n                type: 'error',\n                payload: { error: error.message }\n            });\n        }\n    }\n\n    async function handleAIMessage(payload: any) {\n        const { messages, provider, modelId } = payload;\n\n        sendMessage({ type: 'messageLoading' });\n        log('info', `Processing message with ${provider} (${modelId})`);\n\n        try {\n            // System Prompt with Tool Definitions\n            const systemPrompt = `You are VibeAll, an advanced AI coding assistant.\nYou can perform file operations. To do so, output a single JSON block strictly in this format:\n\\`\\`\\`json\n{\n  \"tools\": [\n    { \"name\": \"createDirectory\", \"args\": { \"path\": \"project_name\" } },\n    { \"name\": \"createFile\", \"args\": { \"path\": \"project_name/src/index.ts\", \"content\": \"...\" } }\n  ]\n}\n\\`\\`\\`\nIMPORTANT Rules:\n1. ALWAYS create a root folder for the project first (e.g., \"my-app\"). All subsequent files must be inside this folder.\n2. Use \"createDirectory\" explicitly for subdirectories (e.g., \"my-app/src\").\n3. Use \"createInGen\" ONLY for quick isolated temporary tests.\n4. For full projects, use \"createFile\" and \"createDirectory\".\n5. Output the JSON block at the end of your response.`;\n\n            // Add system prompt\n            let messagesWithContext = [...messages];\n            if (messagesWithContext.length > 0) {\n                messagesWithContext.unshift({ role: 'system', content: systemPrompt });\n            }\n\n            // Add retrieved context\n            if (context) {\n                const firstUserMsg = messagesWithContext.find(m => m.role === 'user');\n                if (firstUserMsg) {\n                    firstUserMsg.content = `[Context Files]:\\n${context}\\n\\n${firstUserMsg.content}`;\n                }\n            }\n\n            // Ensure API key is loaded\n            if (!modelClient.hasClient(provider)) {\n                const apiKey = await storageManager.getAPIKey(provider);\n                if (apiKey) {\n                    modelClient.setAPIKey(provider, apiKey);\n                } else {\n                    throw new Error(`No API key found for ${provider}. Please add one in settings.`);\n                }\n            }\n\n            // Send to AI\n            const response = await modelClient.sendMessage(\n                { provider, modelId },\n                messagesWithContext\n            );\n\n            // Parse and Execute Tools\n            const content = response.content;\n\n            // Try matching code blocks first\n            let toolJsonString = null;\n            const codeBlockRegex = /```(?:json)?\\s*({[\\s\\S]*?\"tools\"[\\s\\S]*?})\\s*```/;\n            const match = content.match(codeBlockRegex);\n\n            if (match) {\n                toolJsonString = match[1];\n            } else {\n                // Fallback: try to find a raw JSON object containing \"tools\"\n                const rawJsonRegex = /({[\\s\\S]*?\"tools\"\\s*:\\s*\\[[\\s\\S]*?}\\s*])/;\n                const rawMatch = content.match(rawJsonRegex);\n                if (rawMatch) {\n                    toolJsonString = rawMatch[1];\n                }\n            }\n\n            if (toolJsonString) {\n                try {\n                    // unexpected token cleanup (sometimes models output trailing commas)\n                    // This is a simple parse try.\n                    const toolData = JSON.parse(toolJsonString);\n                    if (toolData.tools && Array.isArray(toolData.tools)) {\n                        log('info', `Found ${toolData.tools.length} tools to execute`);\n                        await executeTools(toolData.tools);\n                    }\n                } catch (e) {\n                    log('error', 'Failed to parse tool JSON', e);\n                    console.error('Raw JSON string that failed:', toolJsonString);\n                }\n            } else {\n                // Fallback: Parse standard code blocks as file creations\n                log('info', 'No tool JSON found, attempting to parse code blocks');\n                const extractedTools = parseCodeBlocksToTools(content);\n\n                if (extractedTools.length > 0) {\n                    log('info', `Found ${extractedTools.length} code blocks to turn into files`);\n                    await executeTools(extractedTools);\n                } else {\n                    log('info', 'No executable content found in response');\n                }\n            }\n\n            // Save chat history\n            const updatedMessages = [\n                ...messages,\n                {\n                    id: Date.now().toString(),\n                    role: 'assistant',\n                    content: response.content,\n                    timestamp: Date.now(),\n                    model: modelId,\n                    tokens: response.usage?.total_tokens,\n                    reasoning_details: response.reasoning_details\n                }\n            ];\n            await storageManager.saveChatHistory(updatedMessages);\n\n            // Update usage stats\n            const stats = storageManager.getUsageStats();\n            if (!stats[provider]) {\n                stats[provider] = { requests: 0, tokens: 0, lastUsed: 0 };\n            }\n            stats[provider].requests += 1;\n            stats[provider].tokens += (response.usage?.total_tokens || 0);\n            stats[provider].lastUsed = Date.now();\n            await storageManager.updateUsageStats(stats);\n\n\n            sendMessage({\n                type: 'messageResponse',\n                payload: {\n                    content: response.content,\n                    model: modelId,\n                    tokens: response.usage?.total_tokens,\n                    usedProvider: provider,\n                    reasoning_details: response.reasoning_details\n                }\n            });\n\n            log('info', `AI Response received from ${provider}`, { tokens: response.usage?.total_tokens });\n\n        } catch (error: any) {\n            log('error', `AI processing failed: ${error.message}`, error);\n            sendMessage({\n                type: 'messageError',\n                payload: { error: error.message }\n            });\n        }\n    }\n\n    async function applyCodeToFile(code: string, _filePath: string) {\n        try {\n            const editor = vscode.window.activeTextEditor;\n            if (!editor) {\n                vscode.window.showErrorMessage('No active editor');\n                return;\n            }\n\n            await editor.edit(editBuilder => {\n                const document = editor.document;\n                const lastLine = document.lineAt(document.lineCount - 1);\n                const range = new vscode.Range(\n                    new vscode.Position(0, 0),\n                    lastLine.range.end\n                );\n                editBuilder.replace(range, code);\n            });\n\n            vscode.window.showInformationMessage('Code applied successfully!');\n            log('info', 'Code applied to file');\n        } catch (error: any) {\n            vscode.window.showErrorMessage(`Failed to apply code: ${error.message}`);\n            log('error', 'Failed to apply code', error);\n        }\n    }\n\n    async function handleFileSystemAction(payload: any) {\n        const { action, path: filePath, content } = payload;\n        try {\n            let result;\n            switch (action) {\n                case 'createFile':\n                    result = await fileSystemManager.createFile(filePath, content);\n                    log('info', `Created file: ${result}`);\n                    break;\n                case 'createDirectory':\n                    result = await fileSystemManager.createDirectory(filePath);\n                    log('info', `Created directory: ${result}`);\n                    break;\n                case 'readFile':\n                    result = await fileSystemManager.readFile(filePath);\n                    log('info', `Read file: ${filePath}`);\n                    break;\n                case 'listFiles':\n                    result = await fileSystemManager.listFiles(filePath);\n                    log('info', `Listed directory: ${filePath}`);\n                    break;\n                case 'createInGen':\n                    result = await fileSystemManager.createInGen(filePath, content);\n                    log('info', `Created in /gen: ${result}`);\n                    break;\n                default:\n                    throw new Error(`Unknown file command: ${action}`);\n            }\n\n            sendMessage({\n                type: 'fileSystemResponse',\n                payload: { action, result, status: 'success' }\n            });\n        } catch (error: any) {\n            log('error', `File system action failed: ${action}`, error);\n            sendMessage({\n                type: 'fileSystemResponse',\n                payload: { action, error: error.message, status: 'error' }\n            });\n        }\n    }\n\n\n    // Helper to execute tools with UI updates\n    async function executeTools(tools: any[]) {\n        sendMessage({\n            type: 'toolExecutionStart',\n            payload: {\n                tools: tools.map((t: any, i: number) => ({ ...t, id: i }))\n            }\n        });\n\n        for (let i = 0; i < tools.length; i++) {\n            const tool = tools[i];\n            sendMessage({\n                type: 'toolStatus',\n                payload: {\n                    id: i,\n                    status: 'running',\n                    tool: tool.name,\n                    path: tool.args.path || tool.args.filename\n                }\n            });\n\n            try {\n                await handleFileSystemAction({ action: tool.name, ...tool.args });\n                sendMessage({\n                    type: 'toolStatus',\n                    payload: { id: i, status: 'completed' }\n                });\n            } catch (toolError: any) {\n                sendMessage({\n                    type: 'toolStatus',\n                    payload: { id: i, status: 'error' }\n                });\n                log('error', `Tool error: ${tool.name}`, toolError);\n            }\n        }\n    }\n\n    function parseCodeBlocksToTools(content: string): any[] {\n        const tools: any[] = [];\n        // Regex to match code blocks: ```lang ... ```\n        const blockRegex = /```(\\w+)?\\n([\\s\\S]*?)```/g;\n        let match;\n\n        while ((match = blockRegex.exec(content)) !== null) {\n            const lang = match[1] || 'txt';\n            const code = match[2];\n\n            // Heuristic: Look inside the code (first few lines) for a comment like \"// filename: src/file.ts\"\n            // or look at the text immediately preceding the block\n\n            // 1. Check inside code\n            let filename = null;\n            const commentMatch = code.match(/^(?:\\/\\/|#|<!--)\\s*(?:filename|file):\\s*([^\\s\\n]+)/m);\n            if (commentMatch) {\n                filename = commentMatch[1];\n            }\n\n            // 2. Check preceding text (look back from match.index)\n            if (!filename) {\n                const precedingText = content.substring(Math.max(0, match.index - 100), match.index);\n                // Look for bold filename or explicit mention: \"**index.html**\" or \"In `script.js`:\"\n                const nameMatch = precedingText.match(/(?:`|\\*\\*)([\\w-]+\\.\\w+)(?:`|\\*\\*)?/);\n                if (nameMatch) {\n                    filename = nameMatch[1];\n                }\n            }\n\n            // 3. Fallback based on language\n            if (!filename) {\n                const ext = lang === 'javascript' ? 'js' : lang === 'typescript' ? 'ts' : lang === 'python' ? 'py' : lang;\n                filename = `generated_file_${tools.length + 1}.${ext}`;\n            }\n\n            // Sanitize filename (remove quotes/paths if too complex, or just accept)\n            filename = filename.trim();\n\n            tools.push({\n                name: 'createFile',\n                args: {\n                    path: filename, // Best effort path\n                    content: code\n                }\n            });\n        }\n\n        return tools;\n    }\n\n    function sendMessage(message: any) {\n        if (currentPanel) {\n            currentPanel.webview.postMessage(message);\n        }\n    }\n\n    function getWebviewContent(webviewUri: vscode.Uri): string {\n        return `<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>VibeAll AI Assistant</title>\n    <style>\n        body {\n            margin: 0;\n            padding: 0;\n            overflow: hidden;\n        }\n        #root {\n            width: 100vw;\n            height: 100vh;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"root\"></div>\n    <script src=\"${webviewUri}\"></script>\n</body>\n</html>`;\n    }\n\n    // Register commands\n    const openCommand = vscode.commands.registerCommand('vibeall.open', showWebview);\n    const settingsCommand = vscode.commands.registerCommand('vibeall.openSettings', () => {\n        showWebview();\n        setTimeout(() => {\n            sendMessage({ type: 'showSettings' });\n        }, 500);\n    });\n\n    context.subscriptions.push(openCommand, settingsCommand);\n\n    // Show webview on activation\n    showWebview();\n}\n\nexport function deactivate() {\n    console.log('VibeAll extension is now deactivated');\n}\n","import * as vscode from 'vscode';\n\nexport interface APIKey {\n    provider: string;\n    key: string;\n}\n\nexport class StorageManager {\n    private context: vscode.ExtensionContext;\n    private secretStorage: vscode.SecretStorage;\n\n    constructor(context: vscode.ExtensionContext) {\n        this.context = context;\n        this.secretStorage = context.secrets;\n    }\n\n    async storeAPIKey(provider: string, key: string): Promise<void> {\n        const storageKey = `vibeall.apikey.${provider.toLowerCase()}`;\n        await this.secretStorage.store(storageKey, key);\n        console.log(`[StorageManager] Stored API key for ${provider}`);\n    }\n\n    async getAPIKey(provider: string): Promise<string | undefined> {\n        const storageKey = `vibeall.apikey.${provider.toLowerCase()}`;\n        const key = await this.secretStorage.get(storageKey);\n        return key;\n    }\n\n    async getAllAPIKeys(): Promise<APIKey[]> {\n        const providers = ['groq', 'google', 'openai', 'cerebras', 'deepseek', 'sambanova', 'anthropic'];\n        const keys: APIKey[] = [];\n\n        for (const provider of providers) {\n            const key = await this.getAPIKey(provider);\n            if (key) {\n                keys.push({ provider, key });\n            }\n        }\n\n        return keys;\n    }\n\n    async deleteAPIKey(provider: string): Promise<void> {\n        const storageKey = `vibeall.apikey.${provider.toLowerCase()}`;\n        await this.secretStorage.delete(storageKey);\n        console.log(`[StorageManager] Deleted API key for ${provider}`);\n    }\n\n    // Settings storage\n    getSettings(): any {\n        return this.context.globalState.get('vibeall.settings', {\n            autoRunCommands: false,\n            autoApplyEdits: false,\n            showMiniDashboard: true,\n            compactMode: false,\n            alwaysShowPlan: false,\n            planMode: false,\n            theme: {\n                primaryColor: '#FF5722',\n                accentColor: '#FF9800',\n                mode: 'dark'\n            }\n        });\n    }\n\n    async updateSettings(settings: any): Promise<void> {\n        await this.context.globalState.update('vibeall.settings', settings);\n        console.log('[StorageManager] Settings updated');\n    }\n\n    // Chat history storage\n    getChatHistory(): any[] {\n        return this.context.globalState.get('vibeall.chatHistory', []);\n    }\n\n    async saveChatHistory(messages: any[]): Promise<void> {\n        await this.context.globalState.update('vibeall.chatHistory', messages);\n    }\n\n    async clearChatHistory(): Promise<void> {\n        await this.context.globalState.update('vibeall.chatHistory', []);\n        console.log('[StorageManager] Chat history cleared');\n    }\n\n    // Usage stats storage\n    getUsageStats(): any {\n        return this.context.globalState.get('vibeall.usageStats', {});\n    }\n\n    async updateUsageStats(stats: any): Promise<void> {\n        await this.context.globalState.update('vibeall.usageStats', stats);\n    }\n}\n","module.exports = require(\"vscode\");","import * as vscode from 'vscode';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\nexport class FileSystemManager {\n    private sandboxRoot: string;\n    private workspaceRoot: string | undefined;\n\n    constructor() {\n        this.workspaceRoot = vscode.workspace.workspaceFolders?.[0].uri.fsPath;\n        this.sandboxRoot = this.workspaceRoot ? path.join(this.workspaceRoot, 'gen') : '';\n    }\n\n    private getAbsolutePath(relativePath: string): string {\n        if (!this.workspaceRoot) {\n            throw new Error('No workspace open');\n        }\n        // If it already looks absolute and starts with workspace root, keep it. \n        // Otherwise join with workspace root.\n        if (path.isAbsolute(relativePath)) {\n            if (!relativePath.startsWith(this.workspaceRoot)) {\n                // For security/safety, strictly simpler to just require relative paths or paths inside workspace\n                // But for now, let's assume valid inputs or re-root them.\n                return relativePath;\n            }\n            return relativePath;\n        }\n        return path.join(this.workspaceRoot, relativePath);\n    }\n\n    private ensureSandbox(filePath: string) {\n        if (!filePath.startsWith(this.sandboxRoot)) {\n            // If strictly enforcing sandbox. \n            // The user wants a 'gen' folder for testing, but also 'update code' for general work.\n            // We 'll use a flag or method distinction later. For now, assume we can write anywhere if allowed.\n        }\n    }\n\n    async createFile(filePath: string, content: string): Promise<string> {\n        const fullPath = this.getAbsolutePath(filePath);\n        await this.ensureDirectoryExists(path.dirname(fullPath));\n        await fs.promises.writeFile(fullPath, content, 'utf8');\n        return fullPath;\n    }\n\n    async createDirectory(dirPath: string): Promise<string> {\n        const fullPath = this.getAbsolutePath(dirPath);\n        await fs.promises.mkdir(fullPath, { recursive: true });\n        return fullPath;\n    }\n\n    async readFile(filePath: string): Promise<string> {\n        const fullPath = this.getAbsolutePath(filePath);\n        return await fs.promises.readFile(fullPath, 'utf8');\n    }\n\n    async listFiles(dirPath: string): Promise<string[]> {\n        const fullPath = this.getAbsolutePath(dirPath);\n        const entries = await fs.promises.readdir(fullPath, { withFileTypes: true });\n        return entries.map(entry => {\n            return path.join(dirPath, entry.name);\n        });\n    }\n\n    async deleteFile(filePath: string): Promise<void> {\n        const fullPath = this.getAbsolutePath(filePath);\n        await fs.promises.unlink(fullPath);\n    }\n\n    private async ensureDirectoryExists(dirPath: string) {\n        try {\n            await fs.promises.access(dirPath);\n        } catch {\n            await fs.promises.mkdir(dirPath, { recursive: true });\n        }\n    }\n\n    // Helper for the 'gen' folder requirement\n    async createInGen(filename: string, content: string): Promise<string> {\n        if (!this.workspaceRoot) throw new Error('No workspace');\n        const genPath = path.join(this.workspaceRoot, 'gen', filename);\n        await this.createFile(genPath, content);\n        return genPath;\n    }\n}\n","import { BaseAPIClient } from './BaseAPIClient';\nimport { StreamResponse } from '../types';\n\nexport class GroqClient extends BaseAPIClient {\n    constructor(apiKey: string) {\n        super(apiKey, 'https://api.groq.com/openai/v1');\n    }\n\n    async sendMessage(\n        modelId: string,\n        messages: any[]\n    ): Promise<StreamResponse> {\n        const response = await this.makeRequest('/chat/completions', {\n            model: modelId,\n            messages,\n            temperature: 0.7,\n            max_tokens: 8192\n        });\n\n        const data = await response.json();\n\n        return {\n            content: data.choices[0].message.content,\n            done: true,\n            model: data.model,\n            tokens: data.usage?.total_tokens\n        };\n    }\n}\n","import { GroqClient } from './GroqClient';\nimport { GoogleClient } from './GoogleClient';\nimport { OpenAIClient } from './OpenAIClient';\nimport { AnthropicClient } from './AnthropicClient';\nimport { BytezClient } from './BytezClient';\nimport { BaseAPIClient } from './BaseAPIClient';\n\nexport interface ModelConfig {\n    provider: string;\n    modelId: string;\n    apiKey?: string;\n}\n\nexport class ModelClient {\n    private clients: Map<string, BaseAPIClient> = new Map();\n\n    constructor() {\n        // Clients will be initialized when API keys are provided\n    }\n\n    setAPIKey(provider: string, apiKey: string): void {\n        const normalizedProvider = provider.toLowerCase();\n        switch (normalizedProvider) {\n            case 'groq':\n                this.clients.set('groq', new GroqClient(apiKey));\n                break;\n            case 'google':\n                this.clients.set('google', new GoogleClient(apiKey));\n                break;\n            case 'anthropic':\n                this.clients.set('anthropic', new AnthropicClient(apiKey));\n                break;\n            case 'openai':\n            case 'cerebras':\n            case 'deepseek':\n            case 'sambanova':\n            case 'xai':\n            case 'novita':\n            case 'aimlapi':\n            case 'openrouter':\n                this.clients.set(normalizedProvider, new OpenAIClient(apiKey, normalizedProvider));\n                break;\n            case 'bytez':\n                this.clients.set('bytez', new BytezClient(apiKey));\n                break;\n        }\n    }\n\n    async sendMessage(config: ModelConfig, messages: any[]): Promise<any> {\n        const { provider, modelId, apiKey } = config;\n\n        // Set API key if provided\n        if (apiKey) {\n            this.setAPIKey(provider, apiKey);\n        }\n\n        const client = this.clients.get(provider.toLowerCase());\n        if (!client) {\n            throw new Error(`No API key configured for provider: ${provider}`);\n        }\n\n        return await client.sendMessage(modelId, messages);\n    }\n\n    hasClient(provider: string): boolean {\n        return this.clients.has(provider.toLowerCase());\n    }\n\n    getAvailableProviders(): string[] {\n        return Array.from(this.clients.keys());\n    }\n}\n","import { BaseAPIClient } from './BaseAPIClient';\nimport { StreamResponse } from '../types';\n\nexport class OpenAIClient extends BaseAPIClient {\n    private provider: string;\n\n    constructor(apiKey: string, provider: string = 'openai') {\n        const baseURLs: { [key: string]: string } = {\n            'openai': 'https://api.openai.com/v1',\n            'cerebras': 'https://api.cerebras.ai/v1',\n            'deepseek': 'https://api.deepseek.com/v1',\n            'sambanova': 'https://api.sambanova.ai/v1',\n            'xai': 'https://api.x.ai/v1',\n            'novita': 'https://api.novita.ai/openai',\n            'aimlapi': 'https://api.aimlapi.com/v1',\n            'openrouter': 'https://openrouter.ai/api/v1'\n        };\n        super(apiKey, baseURLs[provider] || baseURLs['openai']);\n        this.provider = provider;\n    }\n\n    async sendMessage(\n        modelId: string,\n        messages: any[]\n    ): Promise<StreamResponse> {\n        const payload: any = {\n            model: modelId,\n            messages,\n            temperature: 0.7,\n            max_tokens: modelId === 'kat-coder' ? 1000 : 4096\n        };\n\n        // Enable reasoning for OpenRouter thinking models\n        if (this.provider === 'openrouter' && (modelId.includes('think') || modelId.includes('reason'))) {\n            payload.reasoning = { enabled: true };\n        }\n\n        const response = await this.makeRequest('/chat/completions', payload);\n\n        const data = await response.json();\n\n        return {\n            content: data.choices[0].message.content,\n            done: true,\n            model: data.model,\n            tokens: data.usage?.total_tokens,\n            reasoning_details: data.choices[0].message.reasoning_details\n        };\n    }\n}\n","import { BaseAPIClient } from './BaseAPIClient';\nimport { StreamResponse } from '../types';\n\nexport class GoogleClient extends BaseAPIClient {\n    constructor(apiKey: string) {\n        super(apiKey, 'https://generativelanguage.googleapis.com/v1beta');\n    }\n\n    async sendMessage(\n        modelId: string,\n        messages: any[]\n    ): Promise<StreamResponse> {\n        // Convert messages to Gemini format\n        const contents = messages.map(msg => ({\n            role: msg.role === 'assistant' ? 'model' : 'user',\n            parts: [{ text: msg.content }]\n        }));\n\n        const response = await fetch(\n            `${this.baseURL}/models/${modelId}:generateContent?key=${this.apiKey}`,\n            {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({ contents })\n            }\n        );\n\n        if (!response.ok) {\n            throw new Error(`Gemini API error: ${response.statusText}`);\n        }\n\n        const data = await response.json();\n\n        return {\n            content: data.candidates[0].content.parts[0].text,\n            done: true,\n            model: modelId,\n            tokens: data.usageMetadata?.totalTokenCount\n        };\n    }\n}\n","import * as vscode from 'vscode';\n\nexport class ContextManager {\n    async getActiveFileContext(): Promise<string> {\n        const editor = vscode.window.activeTextEditor;\n        if (!editor) {\n            return '';\n        }\n\n        const document = editor.document;\n        const selection = editor.selection;\n\n        let context = `File: ${document.fileName}\\n`;\n        context += `Language: ${document.languageId}\\n\\n`;\n\n        if (!selection.isEmpty) {\n            context += `Selected code:\\n\\`\\`\\`${document.languageId}\\n`;\n            context += document.getText(selection);\n            context += '\\n```\\n';\n        } else {\n            context += `Full file content:\\n\\`\\`\\`${document.languageId}\\n`;\n            context += document.getText();\n            context += '\\n```\\n';\n        }\n\n        return context;\n    }\n\n    async getWorkspaceContext(): Promise<string> {\n        const workspaceFolders = vscode.workspace.workspaceFolders;\n        if (!workspaceFolders || workspaceFolders.length === 0) {\n            return '';\n        }\n\n        let context = 'Workspace Information:\\n';\n        context += `Root: ${workspaceFolders[0].uri.fsPath}\\n`;\n\n        // Get package.json if it exists\n        try {\n            const packageJsonUri = vscode.Uri.joinPath(workspaceFolders[0].uri, 'package.json');\n            const packageJsonContent = await vscode.workspace.fs.readFile(packageJsonUri);\n            const packageJson = JSON.parse(packageJsonContent.toString());\n\n            context += '\\nProject Dependencies:\\n';\n            if (packageJson.dependencies) {\n                context += 'Dependencies: ' + Object.keys(packageJson.dependencies).join(', ') + '\\n';\n            }\n            if (packageJson.devDependencies) {\n                context += 'DevDependencies: ' + Object.keys(packageJson.devDependencies).join(', ') + '\\n';\n            }\n        } catch (error) {\n            // package.json doesn't exist or can't be read\n        }\n\n        return context;\n    }\n\n    async getDiagnosticsContext(): Promise<string> {\n        const editor = vscode.window.activeTextEditor;\n        if (!editor) {\n            return '';\n        }\n\n        const diagnostics = vscode.languages.getDiagnostics(editor.document.uri);\n        if (diagnostics.length === 0) {\n            return '';\n        }\n\n        let context = '\\nCurrent Errors/Warnings:\\n';\n        diagnostics.forEach((diagnostic, index) => {\n            const severity = diagnostic.severity === vscode.DiagnosticSeverity.Error ? 'ERROR' : 'WARNING';\n            context += `${index + 1}. [${severity}] Line ${diagnostic.range.start.line + 1}: ${diagnostic.message}\\n`;\n        });\n\n        return context;\n    }\n\n    async getFullContext(): Promise<string> {\n        const fileContext = await this.getActiveFileContext();\n        const workspaceContext = await this.getWorkspaceContext();\n        const diagnosticsContext = await this.getDiagnosticsContext();\n\n        return `${workspaceContext}\\n${fileContext}\\n${diagnosticsContext}`;\n    }\n}\n","import { BaseAPIClient } from './BaseAPIClient';\nimport { StreamResponse } from '../types';\n\nexport class AnthropicClient extends BaseAPIClient {\n    constructor(apiKey: string) {\n        super(apiKey, 'https://api.anthropic.com/v1');\n    }\n\n    async sendMessage(\n        modelId: string,\n        messages: any[]\n    ): Promise<StreamResponse> {\n        // Extract system message if present (Anthropic requires it top-level)\n        let systemPrompt = '';\n        const anthropicMessages = messages.filter(msg => {\n            if (msg.role === 'system') {\n                systemPrompt += msg.content + '\\n';\n                return false;\n            }\n            return true;\n        });\n\n        const body = {\n            model: modelId,\n            messages: anthropicMessages,\n            max_tokens: 8192,\n            system: systemPrompt.trim() || undefined\n        };\n\n        const response = await fetch(`${this.baseURL}/messages`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'x-api-key': this.apiKey, // Anthropic uses x-api-key\n                'anthropic-version': '2023-06-01'\n            },\n            body: JSON.stringify(body)\n        });\n\n        if (!response.ok) {\n            const errorText = await response.text();\n            throw new Error(`Anthropic API error: ${response.status} - ${errorText}`);\n        }\n\n        const data = await response.json();\n\n        return {\n            content: data.content[0].text,\n            done: true,\n            model: data.model,\n            tokens: data.usage?.output_tokens\n        };\n    }\n}\n","module.exports = require(\"fs\");","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(265);\n"],"names":["constructor","apiKey","baseURL","this","makeRequest","endpoint","body","options","response","fetch","method","headers","JSON","stringify","ok","Error","statusText","BytezClient","BaseAPIClient","super","sendMessage","modelId","messages","input","isEmbedding","includes","isMedia","lastMsg","length","content","requestBody","params","max_tokens","temperature","output","json","Array","isArray","done","model","tokens","url","errorText","text","status","context","console","log","storageManager","StorageManager","fileSystemManager","ContextManager","FileSystemManager","modelClient","ModelClient","outputChannel","vscode","window","createOutputChannel","currentPanel","logs","level","message","details","entry","id","Date","now","toString","Math","random","substr","timestamp","push","slice","toLocaleTimeString","appendLine","toUpperCase","type","payload","async","apiKeys","getAllAPIKeys","forEach","provider","key","setAPIKey","keyLength","error","loadAPIKeys","showWebview","columnToShowIn","activeTextEditor","viewColumn","undefined","reveal","createWebviewPanel","ViewColumn","Two","enableScripts","retainContextWhenHidden","localResourceRoots","Uri","file","path","join","extensionPath","webviewUri","webview","asWebviewUri","html","getWebviewContent","onDidReceiveMessage","getSettings","updateSettings","getChatHistory","clearChatHistory","getUsageStats","storeAPIKey","systemPrompt","messagesWithContext","unshift","role","firstUserMsg","find","m","hasClient","getAPIKey","toolJsonString","codeBlockRegex","match","rawJsonRegex","rawMatch","toolData","parse","tools","executeTools","e","extractedTools","blockRegex","exec","lang","code","filename","commentMatch","nameMatch","substring","max","index","ext","trim","name","args","parseCodeBlocksToTools","updatedMessages","usage","total_tokens","reasoning_details","saveChatHistory","stats","requests","lastUsed","updateUsageStats","usedProvider","handleAIMessage","editor","showErrorMessage","edit","editBuilder","document","lastLine","lineAt","lineCount","range","Range","Position","end","replace","showInformationMessage","applyCodeToFile","filePath","handleFileSystemAction","handleWebviewMessage","subscriptions","onDidDispose","action","result","createFile","createDirectory","readFile","listFiles","createInGen","map","t","i","tool","toolError","postMessage","openCommand","commands","registerCommand","settingsCommand","setTimeout","secretStorage","secrets","storageKey","toLowerCase","store","get","providers","keys","deleteAPIKey","delete","globalState","autoRunCommands","autoApplyEdits","showMiniDashboard","compactMode","alwaysShowPlan","planMode","theme","primaryColor","accentColor","mode","settings","update","module","exports","require","workspaceRoot","workspace","workspaceFolders","uri","fsPath","sandboxRoot","getAbsolutePath","relativePath","isAbsolute","startsWith","ensureSandbox","fullPath","ensureDirectoryExists","dirname","fs","promises","writeFile","dirPath","mkdir","recursive","readdir","withFileTypes","deleteFile","unlink","access","genPath","GroqClient","data","choices","clients","Map","normalizedProvider","set","GoogleClient","AnthropicClient","OpenAIClient","config","client","has","getAvailableProviders","from","baseURLs","reasoning","enabled","contents","msg","parts","candidates","usageMetadata","totalTokenCount","getActiveFileContext","selection","fileName","languageId","isEmpty","getText","getWorkspaceContext","packageJsonUri","joinPath","packageJsonContent","packageJson","dependencies","Object","devDependencies","getDiagnosticsContext","diagnostics","languages","getDiagnostics","diagnostic","severity","DiagnosticSeverity","start","line","getFullContext","fileContext","filter","system","output_tokens","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"ignoreList":[],"sourceRoot":""}
{"version":3,"file":"extension.js","mappings":"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","sources":[".././src/api/BaseAPIClient.ts",".././src/api/BytezClient.ts",".././src/extension.ts",".././src/managers/StorageManager.ts","../external commonjs \"vscode\"",".././src/api/GroqClient.ts",".././src/api/ModelClient.ts",".././src/api/OpenAIClient.ts",".././src/api/GoogleClient.ts",".././src/managers/ContextManager.ts",".././src/api/AnthropicClient.ts","../external node-commonjs \"path\"","../webpack/bootstrap","../webpack/startup"],"sourcesContent":["import { StreamResponse } from '../types';\n\nexport abstract class BaseAPIClient {\n    protected apiKey: string;\n    protected baseURL: string;\n\n    constructor(apiKey: string, baseURL: string) {\n        this.apiKey = apiKey;\n        this.baseURL = baseURL;\n    }\n\n    abstract sendMessage(\n        modelId: string,\n        messages: any[],\n        options?: any\n    ): Promise<StreamResponse>;\n\n    protected async makeRequest(\n        endpoint: string,\n        body: any,\n        options?: RequestInit\n    ): Promise<Response> {\n        const response = await fetch(`${this.baseURL}${endpoint}`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'Authorization': `Bearer ${this.apiKey}`,\n                ...options?.headers\n            },\n            body: JSON.stringify(body),\n            ...options\n        });\n\n        if (!response.ok) {\n            throw new Error(`API request failed: ${response.statusText}`);\n        }\n\n        return response;\n    }\n}\n","import { BaseAPIClient } from './BaseAPIClient';\nimport { StreamResponse } from '../types';\n\nexport class BytezClient extends BaseAPIClient {\n    constructor(apiKey: string) {\n        super(apiKey, 'https://api.bytez.com/models/v2');\n    }\n\n    async sendMessage(\n        modelId: string,\n        messages: any[]\n    ): Promise<StreamResponse> {\n        // Determine input format based on model type or just pass messages for LLMs\n        // For non-chat models (like stable-diffusion), we might want to extract the last prompt.\n        // But for now, let's implement the chat flow primarily.\n\n        let input: any = messages;\n\n        const isEmbedding = modelId.includes('sentence-transformers') ||\n            modelId.includes('bge') ||\n            modelId.includes('nomic') ||\n            modelId.includes('clip') ||\n            modelId.includes('siglip');\n\n        const isMedia = modelId.includes('stable') ||\n            modelId.includes('whisper') ||\n            modelId.includes('bark');\n\n        // Simple heuristic: if modelId implies image generation or embedding, use the last user message text\n        if (isEmbedding || isMedia) {\n            const lastMsg = messages[messages.length - 1];\n            input = lastMsg ? lastMsg.content : '';\n        }\n\n        const requestBody: any = { input };\n\n        // Only add params for models that support it (LLMs)\n        // Whisper/Bark/Embeddings don't use 'max_tokens' in the same way or error out\n        if (!isEmbedding && !modelId.includes('whisper') && !modelId.includes('bark')) {\n            requestBody.params = {\n                max_tokens: 1024,\n                temperature: 0.7\n            };\n        }\n\n        const response = await this.makeRequest(`/${modelId}`, requestBody);\n\n        const data = await response.json();\n        const output = data.output;\n\n        // Handle output format which can vary\n        let content = '';\n        if (typeof output === 'string') {\n            content = output;\n        } else if (Array.isArray(output) && output[0] && output[0].content) {\n            // Chat output: [{ role: 'assistant', content: '...' }]\n            content = output[0].content;\n        } else {\n            content = JSON.stringify(output);\n        }\n\n        return {\n            content: content,\n            done: true,\n            model: modelId,\n            tokens: 0 // Usage not strictly returned in standard wrapper\n        };\n    }\n\n    // Override makeRequest to custom format headers slightly different if needed\n    // Client.ts says: Authorization: Key ${apiKey}\n    protected async makeRequest(endpoint: string, body: any): Promise<Response> {\n        const url = `${this.baseURL}${endpoint}`;\n        const headers = {\n            'Content-Type': 'application/json',\n            'Authorization': `Key ${this.apiKey}`\n        };\n\n        const response = await fetch(url, {\n            method: 'POST',\n            headers,\n            body: JSON.stringify(body)\n        });\n\n        if (!response.ok) {\n            const errorText = await response.text();\n            throw new Error(`API Request Failed: ${response.status} ${response.statusText} - ${errorText}`);\n        }\n\n        return response;\n    }\n}\n","import * as vscode from 'vscode';\nimport * as path from 'path';\nimport { StorageManager } from './managers/StorageManager';\nimport { ContextManager } from './managers/ContextManager';\nimport { ModelClient } from './api/ModelClient';\n\ninterface LogEntry {\n    id: string;\n    timestamp: number;\n    level: 'info' | 'warning' | 'error' | 'debug';\n    message: string;\n    details?: any;\n}\n\nexport function activate(context: vscode.ExtensionContext) {\n    console.log('VibeAll extension is now active!');\n\n    const storageManager = new StorageManager(context);\n    const contextManager = new ContextManager();\n    const modelClient = new ModelClient();\n\n    // Output channel for logging\n    const outputChannel = vscode.window.createOutputChannel('VibeAll');\n\n    // In-memory logs\n    let logs: LogEntry[] = [];\n\n    function log(level: 'info' | 'warning' | 'error' | 'debug', message: string, details?: any) {\n        const entry: LogEntry = {\n            id: Date.now().toString() + Math.random().toString(36).substr(2, 9),\n            timestamp: Date.now(),\n            level,\n            message,\n            details\n        };\n\n        logs.push(entry);\n\n        // Keep only last 1000 logs\n        if (logs.length > 1000) {\n            logs = logs.slice(logs.length - 1000);\n        }\n\n        // Send to output channel\n        const timestamp = new Date(entry.timestamp).toLocaleTimeString();\n        outputChannel.appendLine(`[${timestamp}] [${level.toUpperCase()}] ${message}`);\n        if (details) {\n            outputChannel.appendLine(JSON.stringify(details, null, 2));\n        }\n\n        // Broadcast to webview\n        sendMessage({\n            type: 'newLog',\n            payload: entry\n        });\n    }\n\n    // Load API keys on startup\n    loadAPIKeys();\n\n    async function loadAPIKeys() {\n        try {\n            const apiKeys = await storageManager.getAllAPIKeys();\n            apiKeys.forEach(({ provider, key }) => {\n                modelClient.setAPIKey(provider, key);\n                log('info', `Loaded API key for ${provider}`, { keyLength: key.length });\n            });\n            log('info', `Loaded ${apiKeys.length} API keys`);\n        } catch (error: any) {\n            log('error', 'Failed to load API keys', error);\n        }\n    }\n\n    // Create webview panel\n    let currentPanel: vscode.WebviewPanel | undefined = undefined;\n\n    const showWebview = () => {\n        const columnToShowIn = vscode.window.activeTextEditor\n            ? vscode.window.activeTextEditor.viewColumn\n            : undefined;\n\n        if (currentPanel) {\n            currentPanel.reveal(columnToShowIn);\n            return;\n        }\n\n        currentPanel = vscode.window.createWebviewPanel(\n            'vibeall',\n            'VibeAll AI Assistant',\n            vscode.ViewColumn.Two,\n            {\n                enableScripts: true,\n                retainContextWhenHidden: true,\n                localResourceRoots: [\n                    vscode.Uri.file(path.join(context.extensionPath, 'dist'))\n                ]\n            }\n        );\n\n        const webviewUri = currentPanel.webview.asWebviewUri(\n            vscode.Uri.file(path.join(context.extensionPath, 'dist', 'webview.js'))\n        );\n\n        currentPanel.webview.html = getWebviewContent(webviewUri);\n\n        // Handle messages from webview\n        currentPanel.webview.onDidReceiveMessage(\n            async (message) => {\n                await handleWebviewMessage(message);\n            },\n            undefined,\n            context.subscriptions\n        );\n\n        currentPanel.onDidDispose(\n            () => {\n                currentPanel = undefined;\n            },\n            null,\n            context.subscriptions\n        );\n    };\n\n    async function handleWebviewMessage(message: any) {\n        const { type, payload } = message;\n\n        try {\n            switch (type) {\n                case 'getSettings':\n                    sendMessage({\n                        type: 'settings',\n                        payload: storageManager.getSettings()\n                    });\n                    break;\n\n                case 'updateSettings':\n                    await storageManager.updateSettings(payload);\n                    log('info', 'Settings updated');\n                    break;\n\n                case 'getChatHistory':\n                    sendMessage({\n                        type: 'chatHistory',\n                        payload: storageManager.getChatHistory()\n                    });\n                    break;\n\n                case 'clearChat':\n                    await storageManager.clearChatHistory();\n                    sendMessage({ type: 'chatCleared' });\n                    log('info', 'Chat history cleared');\n                    break;\n\n                case 'getLogs':\n                    sendMessage({\n                        type: 'logs',\n                        payload: logs\n                    });\n                    break;\n\n                case 'clearLogs':\n                    logs = [];\n                    sendMessage({\n                        type: 'logs',\n                        payload: []\n                    });\n                    break;\n\n                case 'getUsageStats':\n                    sendMessage({\n                        type: 'usageStats',\n                        payload: storageManager.getUsageStats()\n                    });\n                    break;\n\n                case 'getAPIKeys': {\n                    const apiKeys = await storageManager.getAllAPIKeys();\n                    sendMessage({\n                        type: 'apiKeys',\n                        payload: apiKeys\n                    });\n                    break;\n                }\n\n                case 'storeAPIKey':\n                    try {\n                        const { provider, key } = payload;\n                        await storageManager.storeAPIKey(provider, key);\n                        modelClient.setAPIKey(provider, key);\n\n                        log('info', `API key stored for ${provider}`);\n\n                        sendMessage({\n                            type: 'apiKeyStored',\n                            payload: { provider }\n                        });\n                    } catch (error: any) {\n                        log('error', `Failed to store API key: ${error.message}`);\n                        sendMessage({\n                            type: 'apiKeyError',\n                            payload: { error: error.message }\n                        });\n                    }\n                    break;\n\n                case 'sendMessage':\n                    await handleAIMessage(payload);\n                    break;\n\n                case 'switchModel':\n                    log('info', `Switched model to ${payload.provider} / ${payload.modelId}`);\n                    break;\n\n                case 'applyCode':\n                    await applyCodeToFile(payload.code, payload.filePath);\n                    break;\n\n                default:\n                    console.log(`[VibeAll] Unknown message type: ${type}`);\n            }\n        } catch (error: any) {\n            console.error(`[VibeAll] Error handling message:`, error);\n            log('error', `Error handling message ${type}`, error);\n            sendMessage({\n                type: 'error',\n                payload: { error: error.message }\n            });\n        }\n    }\n\n    async function handleAIMessage(payload: any) {\n        const { messages, provider, modelId } = payload;\n\n        sendMessage({ type: 'messageLoading' });\n        log('info', `Processing message with ${provider} (${modelId})`);\n\n        try {\n            // Get context\n            const context = await contextManager.getFullContext();\n\n            // Add context to the first message if available\n            const messagesWithContext = [...messages];\n            if (context && messagesWithContext.length > 0) {\n                messagesWithContext[0].content = `${context}\\n\\n${messagesWithContext[0].content}`;\n            }\n\n            // Ensure API key is loaded\n            if (!modelClient.hasClient(provider)) {\n                // Try to load from storage one more time\n                const apiKey = await storageManager.getAPIKey(provider);\n                if (apiKey) {\n                    modelClient.setAPIKey(provider, apiKey);\n                } else {\n                    throw new Error(`No API key found for ${provider}. Please add one in settings.`);\n                }\n            }\n\n            // Send to AI\n            const response = await modelClient.sendMessage(\n                { provider, modelId },\n                messagesWithContext\n            );\n\n            // Save chat history\n            const updatedMessages = [\n                ...messages,\n                {\n                    id: Date.now().toString(),\n                    role: 'assistant',\n                    content: response.content,\n                    timestamp: Date.now(),\n                    model: modelId,\n                    tokens: response.usage?.total_tokens\n                }\n            ];\n            await storageManager.saveChatHistory(updatedMessages);\n\n            // Update usage stats\n            const stats = storageManager.getUsageStats();\n            if (!stats[provider]) {\n                stats[provider] = { requests: 0, tokens: 0, lastUsed: 0 };\n            }\n            stats[provider].requests += 1;\n            stats[provider].tokens += (response.usage?.total_tokens || 0);\n            stats[provider].lastUsed = Date.now();\n            await storageManager.updateUsageStats(stats);\n\n\n            sendMessage({\n                type: 'messageResponse',\n                payload: {\n                    content: response.content,\n                    model: modelId,\n                    tokens: response.usage?.total_tokens,\n                    usedProvider: provider\n                }\n            });\n\n            log('info', `AI Response received from ${provider}`, { tokens: response.usage?.total_tokens });\n\n        } catch (error: any) {\n            log('error', `AI processing failed: ${error.message}`, error);\n            sendMessage({\n                type: 'messageError',\n                payload: { error: error.message }\n            });\n        }\n    }\n\n    async function applyCodeToFile(code: string, _filePath: string) {\n        try {\n            const editor = vscode.window.activeTextEditor;\n            if (!editor) {\n                vscode.window.showErrorMessage('No active editor');\n                return;\n            }\n\n            await editor.edit(editBuilder => {\n                const document = editor.document;\n                const lastLine = document.lineAt(document.lineCount - 1);\n                const range = new vscode.Range(\n                    new vscode.Position(0, 0),\n                    lastLine.range.end\n                );\n                editBuilder.replace(range, code);\n            });\n\n            vscode.window.showInformationMessage('Code applied successfully!');\n            log('info', 'Code applied to file');\n        } catch (error: any) {\n            vscode.window.showErrorMessage(`Failed to apply code: ${error.message}`);\n            log('error', 'Failed to apply code', error);\n        }\n    }\n\n    function sendMessage(message: any) {\n        if (currentPanel) {\n            currentPanel.webview.postMessage(message);\n        }\n    }\n\n    function getWebviewContent(webviewUri: vscode.Uri): string {\n        return `<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>VibeAll AI Assistant</title>\n    <style>\n        body {\n            margin: 0;\n            padding: 0;\n            overflow: hidden;\n        }\n        #root {\n            width: 100vw;\n            height: 100vh;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"root\"></div>\n    <script src=\"${webviewUri}\"></script>\n</body>\n</html>`;\n    }\n\n    // Register commands\n    const openCommand = vscode.commands.registerCommand('vibeall.open', showWebview);\n    const settingsCommand = vscode.commands.registerCommand('vibeall.openSettings', () => {\n        showWebview();\n        setTimeout(() => {\n            sendMessage({ type: 'showSettings' });\n        }, 500);\n    });\n\n    context.subscriptions.push(openCommand, settingsCommand);\n\n    // Show webview on activation\n    showWebview();\n}\n\nexport function deactivate() {\n    console.log('VibeAll extension is now deactivated');\n}\n","import * as vscode from 'vscode';\n\nexport interface APIKey {\n    provider: string;\n    key: string;\n}\n\nexport class StorageManager {\n    private context: vscode.ExtensionContext;\n    private secretStorage: vscode.SecretStorage;\n\n    constructor(context: vscode.ExtensionContext) {\n        this.context = context;\n        this.secretStorage = context.secrets;\n    }\n\n    async storeAPIKey(provider: string, key: string): Promise<void> {\n        const storageKey = `vibeall.apikey.${provider.toLowerCase()}`;\n        await this.secretStorage.store(storageKey, key);\n        console.log(`[StorageManager] Stored API key for ${provider}`);\n    }\n\n    async getAPIKey(provider: string): Promise<string | undefined> {\n        const storageKey = `vibeall.apikey.${provider.toLowerCase()}`;\n        const key = await this.secretStorage.get(storageKey);\n        return key;\n    }\n\n    async getAllAPIKeys(): Promise<APIKey[]> {\n        const providers = ['groq', 'google', 'openai', 'cerebras', 'deepseek', 'sambanova', 'anthropic'];\n        const keys: APIKey[] = [];\n\n        for (const provider of providers) {\n            const key = await this.getAPIKey(provider);\n            if (key) {\n                keys.push({ provider, key });\n            }\n        }\n\n        return keys;\n    }\n\n    async deleteAPIKey(provider: string): Promise<void> {\n        const storageKey = `vibeall.apikey.${provider.toLowerCase()}`;\n        await this.secretStorage.delete(storageKey);\n        console.log(`[StorageManager] Deleted API key for ${provider}`);\n    }\n\n    // Settings storage\n    getSettings(): any {\n        return this.context.globalState.get('vibeall.settings', {\n            autoRunCommands: false,\n            autoApplyEdits: false,\n            showMiniDashboard: true,\n            compactMode: false,\n            alwaysShowPlan: false,\n            planMode: false,\n            theme: {\n                primaryColor: '#FF5722',\n                accentColor: '#FF9800',\n                mode: 'dark'\n            }\n        });\n    }\n\n    async updateSettings(settings: any): Promise<void> {\n        await this.context.globalState.update('vibeall.settings', settings);\n        console.log('[StorageManager] Settings updated');\n    }\n\n    // Chat history storage\n    getChatHistory(): any[] {\n        return this.context.globalState.get('vibeall.chatHistory', []);\n    }\n\n    async saveChatHistory(messages: any[]): Promise<void> {\n        await this.context.globalState.update('vibeall.chatHistory', messages);\n    }\n\n    async clearChatHistory(): Promise<void> {\n        await this.context.globalState.update('vibeall.chatHistory', []);\n        console.log('[StorageManager] Chat history cleared');\n    }\n\n    // Usage stats storage\n    getUsageStats(): any {\n        return this.context.globalState.get('vibeall.usageStats', {});\n    }\n\n    async updateUsageStats(stats: any): Promise<void> {\n        await this.context.globalState.update('vibeall.usageStats', stats);\n    }\n}\n","module.exports = require(\"vscode\");","import { BaseAPIClient } from './BaseAPIClient';\nimport { StreamResponse } from '../types';\n\nexport class GroqClient extends BaseAPIClient {\n    constructor(apiKey: string) {\n        super(apiKey, 'https://api.groq.com/openai/v1');\n    }\n\n    async sendMessage(\n        modelId: string,\n        messages: any[]\n    ): Promise<StreamResponse> {\n        const response = await this.makeRequest('/chat/completions', {\n            model: modelId,\n            messages,\n            temperature: 0.7,\n            max_tokens: 8192\n        });\n\n        const data = await response.json();\n\n        return {\n            content: data.choices[0].message.content,\n            done: true,\n            model: data.model,\n            tokens: data.usage?.total_tokens\n        };\n    }\n}\n","import { GroqClient } from './GroqClient';\nimport { GoogleClient } from './GoogleClient';\nimport { OpenAIClient } from './OpenAIClient';\nimport { AnthropicClient } from './AnthropicClient';\nimport { BytezClient } from './BytezClient';\nimport { BaseAPIClient } from './BaseAPIClient';\n\nexport interface ModelConfig {\n    provider: string;\n    modelId: string;\n    apiKey?: string;\n}\n\nexport class ModelClient {\n    private clients: Map<string, BaseAPIClient> = new Map();\n\n    constructor() {\n        // Clients will be initialized when API keys are provided\n    }\n\n    setAPIKey(provider: string, apiKey: string): void {\n        const normalizedProvider = provider.toLowerCase();\n        switch (normalizedProvider) {\n            case 'groq':\n                this.clients.set('groq', new GroqClient(apiKey));\n                break;\n            case 'google':\n                this.clients.set('google', new GoogleClient(apiKey));\n                break;\n            case 'anthropic':\n                this.clients.set('anthropic', new AnthropicClient(apiKey));\n                break;\n            case 'openai':\n            case 'cerebras':\n            case 'deepseek':\n            case 'sambanova':\n            case 'xai':\n            case 'novita':\n            case 'aimlapi':\n                this.clients.set(normalizedProvider, new OpenAIClient(apiKey, normalizedProvider));\n                break;\n            case 'bytez':\n                this.clients.set('bytez', new BytezClient(apiKey));\n                break;\n        }\n    }\n\n    async sendMessage(config: ModelConfig, messages: any[]): Promise<any> {\n        const { provider, modelId, apiKey } = config;\n\n        // Set API key if provided\n        if (apiKey) {\n            this.setAPIKey(provider, apiKey);\n        }\n\n        const client = this.clients.get(provider.toLowerCase());\n        if (!client) {\n            throw new Error(`No API key configured for provider: ${provider}`);\n        }\n\n        return await client.sendMessage(modelId, messages);\n    }\n\n    hasClient(provider: string): boolean {\n        return this.clients.has(provider.toLowerCase());\n    }\n\n    getAvailableProviders(): string[] {\n        return Array.from(this.clients.keys());\n    }\n}\n","import { BaseAPIClient } from './BaseAPIClient';\nimport { StreamResponse } from '../types';\n\nexport class OpenAIClient extends BaseAPIClient {\n    constructor(apiKey: string, provider: string = 'openai') {\n        const baseURLs: { [key: string]: string } = {\n            'openai': 'https://api.openai.com/v1',\n            'cerebras': 'https://api.cerebras.ai/v1',\n            'deepseek': 'https://api.deepseek.com/v1',\n            'sambanova': 'https://api.sambanova.ai/v1',\n            'xai': 'https://api.x.ai/v1',\n            'novita': 'https://api.novita.ai/openai',\n            'aimlapi': 'https://api.aimlapi.com/v1'\n        };\n        super(apiKey, baseURLs[provider] || baseURLs['openai']);\n    }\n\n    async sendMessage(\n        modelId: string,\n        messages: any[]\n    ): Promise<StreamResponse> {\n        const response = await this.makeRequest('/chat/completions', {\n            model: modelId,\n            messages,\n            temperature: 0.7,\n            max_tokens: modelId === 'kat-coder' ? 1000 : 4096\n        });\n\n        const data = await response.json();\n\n        return {\n            content: data.choices[0].message.content,\n            done: true,\n            model: data.model,\n            tokens: data.usage?.total_tokens\n        };\n    }\n}\n","import { BaseAPIClient } from './BaseAPIClient';\nimport { StreamResponse } from '../types';\n\nexport class GoogleClient extends BaseAPIClient {\n    constructor(apiKey: string) {\n        super(apiKey, 'https://generativelanguage.googleapis.com/v1beta');\n    }\n\n    async sendMessage(\n        modelId: string,\n        messages: any[]\n    ): Promise<StreamResponse> {\n        // Convert messages to Gemini format\n        const contents = messages.map(msg => ({\n            role: msg.role === 'assistant' ? 'model' : 'user',\n            parts: [{ text: msg.content }]\n        }));\n\n        const response = await fetch(\n            `${this.baseURL}/models/${modelId}:generateContent?key=${this.apiKey}`,\n            {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({ contents })\n            }\n        );\n\n        if (!response.ok) {\n            throw new Error(`Gemini API error: ${response.statusText}`);\n        }\n\n        const data = await response.json();\n\n        return {\n            content: data.candidates[0].content.parts[0].text,\n            done: true,\n            model: modelId,\n            tokens: data.usageMetadata?.totalTokenCount\n        };\n    }\n}\n","import * as vscode from 'vscode';\n\nexport class ContextManager {\n    async getActiveFileContext(): Promise<string> {\n        const editor = vscode.window.activeTextEditor;\n        if (!editor) {\n            return '';\n        }\n\n        const document = editor.document;\n        const selection = editor.selection;\n\n        let context = `File: ${document.fileName}\\n`;\n        context += `Language: ${document.languageId}\\n\\n`;\n\n        if (!selection.isEmpty) {\n            context += `Selected code:\\n\\`\\`\\`${document.languageId}\\n`;\n            context += document.getText(selection);\n            context += '\\n```\\n';\n        } else {\n            context += `Full file content:\\n\\`\\`\\`${document.languageId}\\n`;\n            context += document.getText();\n            context += '\\n```\\n';\n        }\n\n        return context;\n    }\n\n    async getWorkspaceContext(): Promise<string> {\n        const workspaceFolders = vscode.workspace.workspaceFolders;\n        if (!workspaceFolders || workspaceFolders.length === 0) {\n            return '';\n        }\n\n        let context = 'Workspace Information:\\n';\n        context += `Root: ${workspaceFolders[0].uri.fsPath}\\n`;\n\n        // Get package.json if it exists\n        try {\n            const packageJsonUri = vscode.Uri.joinPath(workspaceFolders[0].uri, 'package.json');\n            const packageJsonContent = await vscode.workspace.fs.readFile(packageJsonUri);\n            const packageJson = JSON.parse(packageJsonContent.toString());\n\n            context += '\\nProject Dependencies:\\n';\n            if (packageJson.dependencies) {\n                context += 'Dependencies: ' + Object.keys(packageJson.dependencies).join(', ') + '\\n';\n            }\n            if (packageJson.devDependencies) {\n                context += 'DevDependencies: ' + Object.keys(packageJson.devDependencies).join(', ') + '\\n';\n            }\n        } catch (error) {\n            // package.json doesn't exist or can't be read\n        }\n\n        return context;\n    }\n\n    async getDiagnosticsContext(): Promise<string> {\n        const editor = vscode.window.activeTextEditor;\n        if (!editor) {\n            return '';\n        }\n\n        const diagnostics = vscode.languages.getDiagnostics(editor.document.uri);\n        if (diagnostics.length === 0) {\n            return '';\n        }\n\n        let context = '\\nCurrent Errors/Warnings:\\n';\n        diagnostics.forEach((diagnostic, index) => {\n            const severity = diagnostic.severity === vscode.DiagnosticSeverity.Error ? 'ERROR' : 'WARNING';\n            context += `${index + 1}. [${severity}] Line ${diagnostic.range.start.line + 1}: ${diagnostic.message}\\n`;\n        });\n\n        return context;\n    }\n\n    async getFullContext(): Promise<string> {\n        const fileContext = await this.getActiveFileContext();\n        const workspaceContext = await this.getWorkspaceContext();\n        const diagnosticsContext = await this.getDiagnosticsContext();\n\n        return `${workspaceContext}\\n${fileContext}\\n${diagnosticsContext}`;\n    }\n}\n","import { BaseAPIClient } from './BaseAPIClient';\nimport { StreamResponse } from '../types';\n\nexport class AnthropicClient extends BaseAPIClient {\n    constructor(apiKey: string) {\n        super(apiKey, 'https://api.anthropic.com/v1');\n    }\n\n    async sendMessage(\n        modelId: string,\n        messages: any[]\n    ): Promise<StreamResponse> {\n        // Extract system message if present (Anthropic requires it top-level)\n        let systemPrompt = '';\n        const anthropicMessages = messages.filter(msg => {\n            if (msg.role === 'system') {\n                systemPrompt += msg.content + '\\n';\n                return false;\n            }\n            return true;\n        });\n\n        const body = {\n            model: modelId,\n            messages: anthropicMessages,\n            max_tokens: 8192,\n            system: systemPrompt.trim() || undefined\n        };\n\n        const response = await fetch(`${this.baseURL}/messages`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'x-api-key': this.apiKey, // Anthropic uses x-api-key\n                'anthropic-version': '2023-06-01'\n            },\n            body: JSON.stringify(body)\n        });\n\n        if (!response.ok) {\n            const errorText = await response.text();\n            throw new Error(`Anthropic API error: ${response.status} - ${errorText}`);\n        }\n\n        const data = await response.json();\n\n        return {\n            content: data.content[0].text,\n            done: true,\n            model: data.model,\n            tokens: data.usage?.output_tokens\n        };\n    }\n}\n","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(265);\n"],"names":["constructor","apiKey","baseURL","this","makeRequest","endpoint","body","options","response","fetch","method","headers","JSON","stringify","ok","Error","statusText","BytezClient","BaseAPIClient","super","sendMessage","modelId","messages","input","isEmbedding","includes","isMedia","lastMsg","length","content","requestBody","params","max_tokens","temperature","output","json","Array","isArray","done","model","tokens","url","errorText","text","status","context","console","log","storageManager","StorageManager","contextManager","ContextManager","modelClient","ModelClient","outputChannel","vscode","window","createOutputChannel","currentPanel","logs","level","message","details","entry","id","Date","now","toString","Math","random","substr","timestamp","push","slice","toLocaleTimeString","appendLine","toUpperCase","type","payload","async","apiKeys","getAllAPIKeys","forEach","provider","key","setAPIKey","keyLength","error","loadAPIKeys","showWebview","columnToShowIn","activeTextEditor","viewColumn","undefined","reveal","createWebviewPanel","ViewColumn","Two","enableScripts","retainContextWhenHidden","localResourceRoots","Uri","file","path","join","extensionPath","webviewUri","webview","asWebviewUri","html","getWebviewContent","onDidReceiveMessage","getSettings","updateSettings","getChatHistory","clearChatHistory","getUsageStats","storeAPIKey","getFullContext","messagesWithContext","hasClient","getAPIKey","updatedMessages","role","usage","total_tokens","saveChatHistory","stats","requests","lastUsed","updateUsageStats","usedProvider","handleAIMessage","code","editor","showErrorMessage","edit","editBuilder","document","lastLine","lineAt","lineCount","range","Range","Position","end","replace","showInformationMessage","applyCodeToFile","filePath","handleWebviewMessage","subscriptions","onDidDispose","postMessage","openCommand","commands","registerCommand","settingsCommand","setTimeout","secretStorage","secrets","storageKey","toLowerCase","store","get","providers","keys","deleteAPIKey","delete","globalState","autoRunCommands","autoApplyEdits","showMiniDashboard","compactMode","alwaysShowPlan","planMode","theme","primaryColor","accentColor","mode","settings","update","module","exports","require","GroqClient","data","choices","clients","Map","normalizedProvider","set","GoogleClient","AnthropicClient","OpenAIClient","config","client","has","getAvailableProviders","from","baseURLs","contents","map","msg","parts","candidates","usageMetadata","totalTokenCount","getActiveFileContext","selection","fileName","languageId","isEmpty","getText","getWorkspaceContext","workspaceFolders","workspace","uri","fsPath","packageJsonUri","joinPath","packageJsonContent","fs","readFile","packageJson","parse","dependencies","Object","devDependencies","getDiagnosticsContext","diagnostics","languages","getDiagnostics","diagnostic","index","severity","DiagnosticSeverity","start","line","fileContext","systemPrompt","filter","system","trim","output_tokens","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"ignoreList":[],"sourceRoot":""}